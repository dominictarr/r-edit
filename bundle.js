(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/package.json"
));

require.define("/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction trim (string) {\n  return string.substring(1, string.length - 1)\n}\n\nfunction style (rx, tag) {\n  return function (text) {\n    var m = rx.exec(text)\n    while (m) {\n      text = text.replace(m[0], '<'+tag+'>'+trim(m[0])+'</'+tag+'>')\n      m = rx.exec(text)\n    }\n    return text\n  }\n}\n\nvar italics = style(/_[^_]+_/, 'em')\nvar bold    = style(/\\*[^\\*]+\\*/, 'strong')\nvar code    = style(/`[^`]+`/, 'code')\n\nfunction prefix (rx, tag) {\n  return function (val) {\n    var m = rx.exec(val)\n    if(m) {\n      var l = m[0].length\n      //oh yeah, escape chars...\n      var t = 'function' === typeof tag ? tag(m) : tag\n      return '<'+t+'>'+val.substring(l)+'</'+t+'>'\n    }\n    return val\n  }\n}\n\nvar header = prefix(/^#+/, function (m) { return 'H'+m[0].length })\nvar li = prefix(/^\\s*-+/,  'li')\n\nfunction styles (text) {\n  return header(li(bold(italics(code(text)))))\n}\n\nfunction toHTML (val) {\n  if('\\n' === val)\n    return '<br/>'\n  return styles(val)\n}\n\nfunction defaultTemplate (val, key, el) {\n  if(el)\n    return el.innerHTML = toHTML(val), el\n  var el = document.createElement('span')\n  el.innerHTML = toHTML(val)\n  return el\n}\n\nvar widget = require('r-array/widget')\n\nmodule.exports = function (rEdit, template) {\n  return widget(rEdit, template || defaultTemplate)\n}\n\n//@ sourceURL=/widget.js"
));

require.define("/node_modules/r-array/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/package.json"
));

require.define("/node_modules/r-array/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nmodule.exports = function (rarry, template) {\n\n  var root = document.createElement('div')\n  template = template || function (val, key, el) {\n    function pre (val) { return '<pre>'+JSON.stringify(val)+'</pre>' }\n    if(el)\n      return el.innerHTML = pre(val), el\n    var el = document.createElement('span')\n    el.innerHTML = pre(val)\n    return el\n  }\n\n  console.log(template)\n\n  var elements = {}\n\n  rarry.on('update', function (change) {\n    for(var id in change)\n      update(id, change[id])\n  })\n\n  function update (key, change) {\n    var el\n    if(el = elements[key]) {\n      if(change == null) {\n        return root.removeChild(el)\n      }\n\n      var _el = template.call(el, change, key, el)\n      if(_el != el) {\n        elements[key] = _el\n        div.replaceChild(_el, el)\n      }\n      //else, template updated el.\n      return\n    }\n    el = template.call(null, change, key)\n      console.log(el)\n    //var rarry.indexOf(id)\n    //insert before the element that is already there...\n    var before = elements[rarry.keys[rarry.indexOfKey(key) + 1]]\n    elements[key] = el\n    if(before) {\n      root.insertBefore(el, before)\n    } else {\n      root.appendChild(el)\n    }\n  }\n\n  //render the current contents...\n  rarry.keys.forEach(function (key) {\n    update(key, rarry.get(key))\n  })\n\n  return root\n}\n\n\n//@ sourceURL=/node_modules/r-array/widget.js"
));

require.define("/node_modules/hash-change/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hash-change/package.json"
));

require.define("/node_modules/hash-change/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\n\nvar hashchange = module.exports = new EventEmitter()\n\nwindow.addEventListener('hashchange', function () {\n  hashchange.emit('change', hashchange.hash())\n})\n\nhashchange.hash = function () {\n  return window.location.hash.substring(1)\n}\n\n//@ sourceURL=/node_modules/hash-change/index.js"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/node_modules/rumours/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./server.js\",\"browserify\":\"./client.js\"}\n//@ sourceURL=/node_modules/rumours/package.json"
));

require.define("/node_modules/rumours/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reconnect = require('reconnect')\nvar reloader  = require('client-reloader')\n\nvar Remote    = require('level-scuttlebutt/client')\n\n//putting this inside of page is wrong actually...\n//the pushState and the stream are orthagonal.\n\nmodule.exports = function (config) {\n  config = config || {}\n  var udid = require('udid')(config.name || 'rumours')\n\n  //run on local by default for now...\n  //but later, it will be rumours.nearform.com or whatever...\n\n  var host = config.host || window.location.protocol + '//' + window.location.host\n\n  config.name = config.name || 'rumours'\n  config.prefix = config.prefix || '/rumours'\n  var schema = config.schema || require('./schema')\n  var remote = Remote(schema)\n\n  var r = reconnect(reloader(function (stream) {\n    //this will load the default schema into the bundle,\n    //should do this a different way, to avoid that when using custom schemas.\n    stream.pipe(remote.createRemoteStream()).pipe(stream)\n  }, config)).connect(host + config.prefix)\n\n  r.open = remote.open\n  r.view = remote.view\n\n  return r\n}\n\n\n//@ sourceURL=/node_modules/rumours/client.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./shoe\"}\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/package.json"
));

require.define("/node_modules/rumours/node_modules/reconnect/shoe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar shoe = require('shoe')\n\nmodule.exports = require('./inject')(function (){\n  var args = [].slice.call(arguments)\n  return shoe.apply(null, args)\n})\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/shoe.js"
));

require.define("/node_modules/rumours/node_modules/shoe/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/package.json"
));

require.define("/node_modules/rumours/node_modules/shoe/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar sockjs = require('sockjs-client');\n\nmodule.exports = function (uri, cb) {\n    if (/^\\/\\/[^\\/]+\\//.test(uri)) {\n        uri = window.location.protocol + uri;\n    }\n    else if (!/^https?:\\/\\//.test(uri)) {\n        uri = window.location.protocol + '//'\n            + window.location.host\n            + (/^\\//.test(uri) ? uri : '/' + uri)\n        ;\n    }\n    \n    var stream = new Stream;\n    stream.readable = true;\n    stream.writable = true;\n    \n    var ready = false;\n    var buffer = [];\n    \n    var sock = sockjs(uri);\n    stream.sock = sock;\n    \n    stream.write = function (msg) {\n        if (!ready || buffer.length) buffer.push(msg)\n        else sock.send(msg)\n    };\n    stream.end = function (msg) {\n        if (msg !== undefined) stream.write(msg);\n        if (!ready) {\n            stream._ended = true;\n            return;\n        }\n        stream.writable = false;\n        sock.close();\n    };\n\n    stream.destroy = function () {\n        stream._ended = true;\n        stream.writable = stream.readable = false;\n        buffer.length = 0\n        sock.close();\n    }\n    \n    sock.onopen = function () {\n        if (typeof cb === 'function') cb();\n        ready = true;\n        buffer.forEach(function (msg) {\n            sock.send(msg);\n        });\n        buffer = [];\n        stream.emit('connect')\n        if (stream._ended) stream.end();\n    };\n    sock.onmessage = function (e) {\n        stream.emit('data', e.data);\n    };\n    sock.onclose = function () {\n        stream.emit('end');\n        stream.writable = false;\n        stream.readable = false;\n    };\n    \n    return stream;\n};\n\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/browser.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"sockjs.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/package.json"
));

require.define("/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/sockjs.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License\n\nCopyright (c) 2011-2012 VMware, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// JSON2 by Douglas Crockford (minified).\nvar JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n\n\n//     [*] Including lib/index.js\n// Public object\nvar SockJS = (function(){\n              var _document = document;\n              var _window = window;\n              var utils = {};\n\n\n//         [*] Including lib/reventtarget.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\nvar REventTarget = function() {};\nREventTarget.prototype.addEventListener = function (eventType, listener) {\n    if(!this._listeners) {\n         this._listeners = {};\n    }\n    if(!(eventType in this._listeners)) {\n        this._listeners[eventType] = [];\n    }\n    var arr = this._listeners[eventType];\n    if(utils.arrIndexOf(arr, listener) === -1) {\n        arr.push(listener);\n    }\n    return;\n};\n\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\n    if(!(this._listeners && (eventType in this._listeners))) {\n        return;\n    }\n    var arr = this._listeners[eventType];\n    var idx = utils.arrIndexOf(arr, listener);\n    if (idx !== -1) {\n        if(arr.length > 1) {\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\n        } else {\n            delete this._listeners[eventType];\n        }\n        return;\n    }\n    return;\n};\n\nREventTarget.prototype.dispatchEvent = function (event) {\n    var t = event.type;\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (this['on'+t]) {\n        this['on'+t].apply(this, args);\n    }\n    if (this._listeners && t in this._listeners) {\n        for(var i=0; i < this._listeners[t].length; i++) {\n            this._listeners[t][i].apply(this, args);\n        }\n    }\n};\n//         [*] End of lib/reventtarget.js\n\n\n//         [*] Including lib/simpleevent.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SimpleEvent = function(type, obj) {\n    this.type = type;\n    if (typeof obj !== 'undefined') {\n        for(var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            this[k] = obj[k];\n        }\n    }\n};\n\nSimpleEvent.prototype.toString = function() {\n    var r = [];\n    for(var k in this) {\n        if (!this.hasOwnProperty(k)) continue;\n        var v = this[k];\n        if (typeof v === 'function') v = '[function]';\n        r.push(k + '=' + v);\n    }\n    return 'SimpleEvent(' + r.join(', ') + ')';\n};\n//         [*] End of lib/simpleevent.js\n\n\n//         [*] Including lib/eventemitter.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventEmitter = function(events) {\n    this.events = events || [];\n};\nEventEmitter.prototype.emit = function(type) {\n    var that = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!that.nuked && that['on'+type]) {\n        that['on'+type].apply(that, args);\n    }\n    if (utils.arrIndexOf(that.events, type) === -1) {\n        utils.log('Event ' + JSON.stringify(type) +\n                  ' not listed ' + JSON.stringify(that.events) +\n                  ' in ' + that);\n    }\n};\n\nEventEmitter.prototype.nuke = function(type) {\n    var that = this;\n    that.nuked = true;\n    for(var i=0; i<that.events.length; i++) {\n        delete that[that.events[i]];\n    }\n};\n//         [*] End of lib/eventemitter.js\n\n\n//         [*] Including lib/utils.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\nutils.random_string = function(length, max) {\n    max = max || random_string_chars.length;\n    var i, ret = [];\n    for(i=0; i < length; i++) {\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\n    }\n    return ret.join('');\n};\nutils.random_number = function(max) {\n    return Math.floor(Math.random() * max);\n};\nutils.random_number_string = function(max) {\n    var t = (''+(max - 1)).length;\n    var p = Array(t+1).join('0');\n    return (p + utils.random_number(max)).slice(-t);\n};\n\n// Assuming that url looks like: http://asdasd:111/asd\nutils.getOrigin = function(url) {\n    url += '/';\n    var parts = url.split('/').slice(0, 3);\n    return parts.join('/');\n};\n\nutils.isSameOriginUrl = function(url_a, url_b) {\n    // location.origin would do, but it's not always available.\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split('/').slice(0,3).join('/')\n                ===\n            url_b.split('/').slice(0,3).join('/'));\n};\n\nutils.getParentDomain = function(url) {\n    // ipv4 ip address\n    if (/^[0-9.]*$/.test(url)) return url;\n    // ipv6 ip address\n    if (/^\\[/.test(url)) return url;\n    // no dots\n    if (!(/[.]/.test(url))) return url;\n\n    var parts = url.split('.').slice(1);\n    return parts.join('.');\n};\n\nutils.objectExtend = function(dst, src) {\n    for(var k in src) {\n        if (src.hasOwnProperty(k)) {\n            dst[k] = src[k];\n        }\n    }\n    return dst;\n};\n\nvar WPrefix = '_jp';\n\nutils.polluteGlobalNamespace = function() {\n    if (!(WPrefix in _window)) {\n        _window[WPrefix] = {};\n    }\n};\n\nutils.closeFrame = function (code, reason) {\n    return 'c'+JSON.stringify([code, reason]);\n};\n\nutils.userSetCode = function (code) {\n    return code === 1000 || (code >= 3000 && code <= 4999);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nutils.countRTO = function (rtt) {\n    var rto;\n    if (rtt > 100) {\n        rto = 3 * rtt; // rto > 300msec\n    } else {\n        rto = rtt + 200; // 200msec < rto <= 300msec\n    }\n    return rto;\n}\n\nutils.log = function() {\n    if (_window.console && console.log && console.log.apply) {\n        console.log.apply(console, arguments);\n    }\n};\n\nutils.bind = function(fun, that) {\n    if (fun.bind) {\n        return fun.bind(that);\n    } else {\n        return function() {\n            return fun.apply(that, arguments);\n        };\n    }\n};\n\nutils.flatUrl = function(url) {\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n};\n\nutils.amendUrl = function(url) {\n    var dl = _document.location;\n    if (!url) {\n        throw new Error('Wrong url for SockJS');\n    }\n    if (!utils.flatUrl(url)) {\n        throw new Error('Only basic urls are supported in SockJS');\n    }\n\n    //  '//abc' --> 'http://abc'\n    if (url.indexOf('//') === 0) {\n        url = dl.protocol + url;\n    }\n    // '/abc' --> 'http://localhost:80/abc'\n    if (url.indexOf('/') === 0) {\n        url = dl.protocol + '//' + dl.host + url;\n    }\n    // strip trailing slashes\n    url = url.replace(/[/]+$/,'');\n    return url;\n};\n\n// IE doesn't support [].indexOf.\nutils.arrIndexOf = function(arr, obj){\n    for(var i=0; i < arr.length; i++){\n        if(arr[i] === obj){\n            return i;\n        }\n    }\n    return -1;\n};\n\nutils.arrSkip = function(arr, obj) {\n    var idx = utils.arrIndexOf(arr, obj);\n    if (idx === -1) {\n        return arr.slice();\n    } else {\n        var dst = arr.slice(0, idx);\n        return dst.concat(arr.slice(idx+1));\n    }\n};\n\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\nutils.isArray = Array.isArray || function(value) {\n    return {}.toString.call(value).indexOf('Array') >= 0\n};\n\nutils.delay = function(t, fun) {\n    if(typeof t === 'function') {\n        fun = t;\n        t = 0;\n    }\n    return setTimeout(fun, t);\n};\n\n\n// Chars worth escaping, as defined by Douglas Crockford:\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;\n\n// JSON Quote string. Use native implementation when possible.\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\n    json_escapable.lastIndex = 0;\n    if (json_escapable.test(string)) {\n        string = string.replace(json_escapable, function(a) {\n            return json_lookup[a];\n        });\n    }\n    return '\"' + string + '\"';\n};\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unroll_lookup = function(escapable) {\n    var i;\n    var unrolled = {}\n    var c = []\n    for(i=0; i<65536; i++) {\n        c.push( String.fromCharCode(i) );\n    }\n    escapable.lastIndex = 0;\n    c.join('').replace(escapable, function (a) {\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        return '';\n    });\n    escapable.lastIndex = 0;\n    return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nutils.quote = function(string) {\n    var quoted = JSONQuote(string);\n\n    // In most cases this should be very fast and good enough.\n    extra_escapable.lastIndex = 0;\n    if(!extra_escapable.test(quoted)) {\n        return quoted;\n    }\n\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n\n    return quoted.replace(extra_escapable, function(a) {\n        return extra_lookup[a];\n    });\n}\n\nvar _all_protocols = ['websocket',\n                      'xdr-streaming',\n                      'xhr-streaming',\n                      'iframe-eventsource',\n                      'iframe-htmlfile',\n                      'xdr-polling',\n                      'xhr-polling',\n                      'iframe-xhr-polling',\n                      'jsonp-polling'];\n\nutils.probeProtocols = function() {\n    var probed = {};\n    for(var i=0; i<_all_protocols.length; i++) {\n        var protocol = _all_protocols[i];\n        // User can have a typo in protocol name.\n        probed[protocol] = SockJS[protocol] &&\n                           SockJS[protocol].enabled();\n    }\n    return probed;\n};\n\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\n    var pe = {},\n        protocols = [];\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n    for(var i=0; i<protocols_whitelist.length; i++) {\n        var protocol = protocols_whitelist[i];\n        pe[protocol] = probed[protocol];\n    }\n    var maybe_push = function(protos) {\n        var proto = protos.shift();\n        if (pe[proto]) {\n            protocols.push(proto);\n        } else {\n            if (protos.length > 0) {\n                maybe_push(protos);\n            }\n        }\n    }\n\n    // 1. Websocket\n    if (info.websocket !== false) {\n        maybe_push(['websocket']);\n    }\n\n    // 2. Streaming\n    if (pe['xhr-streaming'] && !info.null_origin) {\n        protocols.push('xhr-streaming');\n    } else {\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-streaming');\n        } else {\n            maybe_push(['iframe-eventsource',\n                        'iframe-htmlfile']);\n        }\n    }\n\n    // 3. Polling\n    if (pe['xhr-polling'] && !info.null_origin) {\n        protocols.push('xhr-polling');\n    } else {\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-polling');\n        } else {\n            maybe_push(['iframe-xhr-polling',\n                        'jsonp-polling']);\n        }\n    }\n    return protocols;\n}\n//         [*] End of lib/utils.js\n\n\n//         [*] Including lib/dom.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// May be used by htmlfile jsonp and transports.\nvar MPrefix = '_sockjs_global';\nutils.createHook = function() {\n    var window_id = 'a' + utils.random_string(8);\n    if (!(MPrefix in _window)) {\n        var map = {};\n        _window[MPrefix] = function(window_id) {\n            if (!(window_id in map)) {\n                map[window_id] = {\n                    id: window_id,\n                    del: function() {delete map[window_id];}\n                };\n            }\n            return map[window_id];\n        }\n    }\n    return _window[MPrefix](window_id);\n};\n\n\n\nutils.attachMessage = function(listener) {\n    utils.attachEvent('message', listener);\n};\nutils.attachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.addEventListener(event, listener, false);\n    } else {\n        // IE quirks.\n        // According to: http://stevesouders.com/misc/test-postmessage.php\n        // the message gets delivered only to 'document', not 'window'.\n        _document.attachEvent(\"on\" + event, listener);\n        // I get 'window' for ie8.\n        _window.attachEvent(\"on\" + event, listener);\n    }\n};\n\nutils.detachMessage = function(listener) {\n    utils.detachEvent('message', listener);\n};\nutils.detachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.removeEventListener(event, listener, false);\n    } else {\n        _document.detachEvent(\"on\" + event, listener);\n        _window.detachEvent(\"on\" + event, listener);\n    }\n};\n\n\nvar on_unload = {};\n// Things registered after beforeunload are to be called immediately.\nvar after_unload = false;\n\nvar trigger_unload_callbacks = function() {\n    for(var ref in on_unload) {\n        on_unload[ref]();\n        delete on_unload[ref];\n    };\n};\n\nvar unload_triggered = function() {\n    if(after_unload) return;\n    after_unload = true;\n    trigger_unload_callbacks();\n};\n\n// Onbeforeunload alone is not reliable. We could use only 'unload'\n// but it's not working in opera within an iframe. Let's use both.\nutils.attachEvent('beforeunload', unload_triggered);\nutils.attachEvent('unload', unload_triggered);\n\nutils.unload_add = function(listener) {\n    var ref = utils.random_string(8);\n    on_unload[ref] = listener;\n    if (after_unload) {\n        utils.delay(trigger_unload_callbacks);\n    }\n    return ref;\n};\nutils.unload_del = function(ref) {\n    if (ref in on_unload)\n        delete on_unload[ref];\n};\n\n\nutils.createIframe = function (iframe_url, error_callback) {\n    var iframe = _document.createElement('iframe');\n    var tref, unload_ref;\n    var unattach = function() {\n        clearTimeout(tref);\n        // Explorer had problems with that.\n        try {iframe.onload = null;} catch (x) {}\n        iframe.onerror = null;\n    };\n    var cleanup = function() {\n        if (iframe) {\n            unattach();\n            // This timeout makes chrome fire onbeforeunload event\n            // within iframe. Without the timeout it goes straight to\n            // onunload.\n            setTimeout(function() {\n                if(iframe) {\n                    iframe.parentNode.removeChild(iframe);\n                }\n                iframe = null;\n            }, 0);\n            utils.unload_del(unload_ref);\n        }\n    };\n    var onerror = function(r) {\n        if (iframe) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    iframe.src = iframe_url;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function(){onerror('onerror');};\n    iframe.onload = function() {\n        // `onload` is triggered before scripts on the iframe are\n        // executed. Give it few seconds to actually load stuff.\n        clearTimeout(tref);\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\n    };\n    _document.body.appendChild(iframe);\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n\nutils.createHtmlfile = function (iframe_url, error_callback) {\n    var doc = new ActiveXObject('htmlfile');\n    var tref, unload_ref;\n    var iframe;\n    var unattach = function() {\n        clearTimeout(tref);\n    };\n    var cleanup = function() {\n        if (doc) {\n            unattach();\n            utils.unload_del(unload_ref);\n            iframe.parentNode.removeChild(iframe);\n            iframe = doc = null;\n            CollectGarbage();\n        }\n    };\n    var onerror = function(r)  {\n        if (doc) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[WPrefix] = _window[WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframe_url;\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n//         [*] End of lib/dom.js\n\n\n//         [*] Including lib/dom2.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AbstractXHRObject = function(){};\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n    var that = this;\n\n    try {\n        that.xhr = new XMLHttpRequest();\n    } catch(x) {};\n\n    if (!that.xhr) {\n        try {\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n        } catch(x) {};\n    }\n    if (_window.ActiveXObject || _window.XDomainRequest) {\n        // IE8 caches even POSTs\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n    }\n\n    // Explorer tends to keep connection open, even after the\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        that.xhr.open(method, url, true);\n    } catch(e) {\n        // IE raises an exception on wrong port.\n        that.emit('finish', 0, '');\n        that._cleanup();\n        return;\n    };\n\n    if (!opts || !opts.no_credentials) {\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n        // \"This never affects same-site requests.\"\n        that.xhr.withCredentials = 'true';\n    }\n    if (opts && opts.headers) {\n        for(var key in opts.headers) {\n            that.xhr.setRequestHeader(key, opts.headers[key]);\n        }\n    }\n\n    that.xhr.onreadystatechange = function() {\n        if (that.xhr) {\n            var x = that.xhr;\n            switch (x.readyState) {\n            case 3:\n                // IE doesn't like peeking into responseText or status\n                // on Microsoft.XMLHTTP and readystate=3\n                try {\n                    var status = x.status;\n                    var text = x.responseText;\n                } catch (x) {};\n                // IE does return readystate == 3 for 404 answers.\n                if (text && text.length > 0) {\n                    that.emit('chunk', status, text);\n                }\n                break;\n            case 4:\n                that.emit('finish', x.status, x.responseText);\n                that._cleanup(false);\n                break;\n            }\n        }\n    };\n    that.xhr.send(payload);\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xhr) return;\n    utils.unload_del(that.unload_ref);\n\n    // IE needs this field to be a function\n    that.xhr.onreadystatechange = function(){};\n\n    if (abort) {\n        try {\n            that.xhr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\nvar XHRCorsObject = utils.XHRCorsObject = function() {\n    var that = this, args = arguments;\n    utils.delay(function(){that._start.apply(that, args);});\n};\nXHRCorsObject.prototype = new AbstractXHRObject();\n\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){\n        that._start(method, url, payload, {\n            no_credentials: true\n        });\n    });\n};\nXHRLocalObject.prototype = new AbstractXHRObject();\n\n\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){that._start(method, url, payload);});\n};\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\nXDRObject.prototype._start = function(method, url, payload) {\n    var that = this;\n    var xdr = new XDomainRequest();\n    // IE caches even POSTs\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\n        that.emit('finish', 0, '');\n        that._cleanup(false);\n    };\n    xdr.onprogress = function() {\n        that.emit('chunk', 200, xdr.responseText);\n    };\n    xdr.onload = function() {\n        that.emit('finish', 200, xdr.responseText);\n        that._cleanup(false);\n    };\n    that.xdr = xdr;\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        // Fails with AccessDenied if port number is bogus\n        that.xdr.open(method, url);\n        that.xdr.send(payload);\n    } catch(x) {\n        onerror();\n    }\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xdr) return;\n    utils.unload_del(that.unload_ref);\n\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\n        that.xdr.onload = null;\n    if (abort) {\n        try {\n            that.xdr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\n// 1. Is natively via XHR\n// 2. Is natively via XDR\n// 3. Nope, but postMessage is there so it should work via the Iframe.\n// 4. Nope, sorry.\nutils.isXHRCorsCapable = function() {\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n        return 1;\n    }\n    // XDomainRequest doesn't work if page is served from file://\n    if (_window.XDomainRequest && _document.domain) {\n        return 2;\n    }\n    if (IframeTransport.enabled()) {\n        return 3;\n    }\n    return 4;\n};\n//         [*] End of lib/dom2.js\n\n\n//         [*] Including lib/sockjs.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SockJS = function(url, dep_protocols_whitelist, options) {\n    if (this === window) {\n        // makes `new` optional\n        return new SockJS(url, dep_protocols_whitelist, options);\n    }\n    \n    var that = this, protocols_whitelist;\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\n                     info: undefined, rtt: undefined};\n    if (options) {\n        utils.objectExtend(that._options, options);\n    }\n    that._base_url = utils.amendUrl(url);\n    that._server = that._options.server || utils.random_number_string(1000);\n    if (that._options.protocols_whitelist &&\n        that._options.protocols_whitelist.length) {\n        protocols_whitelist = that._options.protocols_whitelist;\n    } else {\n        // Deprecated API\n        if (typeof dep_protocols_whitelist === 'string' &&\n            dep_protocols_whitelist.length > 0) {\n            protocols_whitelist = [dep_protocols_whitelist];\n        } else if (utils.isArray(dep_protocols_whitelist)) {\n            protocols_whitelist = dep_protocols_whitelist\n        } else {\n            protocols_whitelist = null;\n        }\n        if (protocols_whitelist) {\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +\n                        'instead of supplying protocol list as a second ' +\n                        'parameter to SockJS constructor.');\n        }\n    }\n    that._protocols = [];\n    that.protocol = null;\n    that.readyState = SockJS.CONNECTING;\n    that._ir = createInfoReceiver(that._base_url);\n    that._ir.onfinish = function(info, rtt) {\n        that._ir = null;\n        if (info) {\n            if (that._options.info) {\n                // Override if user supplies the option\n                info = utils.objectExtend(info, that._options.info);\n            }\n            if (that._options.rtt) {\n                rtt = that._options.rtt;\n            }\n            that._applyInfo(info, rtt, protocols_whitelist);\n            that._didClose();\n        } else {\n            that._didClose(1002, 'Can\\'t connect to server', true);\n        }\n    };\n};\n// Inheritance\nSockJS.prototype = new REventTarget();\n\nSockJS.version = \"0.3.1.7.ga67f.dirty\";\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._debug = function() {\n    if (this._options.debug)\n        utils.log.apply(utils, arguments);\n};\n\nSockJS.prototype._dispatchOpen = function() {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING) {\n        if (that._transport_tref) {\n            clearTimeout(that._transport_tref);\n            that._transport_tref = null;\n        }\n        that.readyState = SockJS.OPEN;\n        that.dispatchEvent(new SimpleEvent(\"open\"));\n    } else {\n        // The server might have been restarted, and lost track of our\n        // connection.\n        that._didClose(1006, \"Server lost session\");\n    }\n};\n\nSockJS.prototype._dispatchMessage = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n            return;\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));\n};\n\nSockJS.prototype._dispatchHeartbeat = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n        return;\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n};\n\nSockJS.prototype._didClose = function(code, reason, force) {\n    var that = this;\n    if (that.readyState !== SockJS.CONNECTING &&\n        that.readyState !== SockJS.OPEN &&\n        that.readyState !== SockJS.CLOSING)\n            throw new Error('INVALID_STATE_ERR');\n    if (that._ir) {\n        that._ir.nuke();\n        that._ir = null;\n    }\n\n    if (that._transport) {\n        that._transport.doCleanup();\n        that._transport = null;\n    }\n\n    var close_event = new SimpleEvent(\"close\", {\n        code: code,\n        reason: reason,\n        wasClean: utils.userSetCode(code)});\n\n    if (!utils.userSetCode(code) &&\n        that.readyState === SockJS.CONNECTING && !force) {\n        if (that._try_next_protocol(close_event)) {\n            return;\n        }\n        close_event = new SimpleEvent(\"close\", {code: 2000,\n                                                reason: \"All transports failed\",\n                                                wasClean: false,\n                                                last_event: close_event});\n    }\n    that.readyState = SockJS.CLOSED;\n\n    utils.delay(function() {\n                   that.dispatchEvent(close_event);\n                });\n};\n\nSockJS.prototype._didMessage = function(data) {\n    var that = this;\n    var type = data.slice(0, 1);\n    switch(type) {\n    case 'o':\n        that._dispatchOpen();\n        break;\n    case 'a':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        for(var i=0; i < payload.length; i++){\n            that._dispatchMessage(payload[i]);\n        }\n        break;\n    case 'm':\n        var payload = JSON.parse(data.slice(1) || 'null');\n        that._dispatchMessage(payload);\n        break;\n    case 'c':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        that._didClose(payload[0], payload[1]);\n        break;\n    case 'h':\n        that._dispatchHeartbeat();\n        break;\n    }\n};\n\nSockJS.prototype._try_next_protocol = function(close_event) {\n    var that = this;\n    if (that.protocol) {\n        that._debug('Closed transport:', that.protocol, ''+close_event);\n        that.protocol = null;\n    }\n    if (that._transport_tref) {\n        clearTimeout(that._transport_tref);\n        that._transport_tref = null;\n    }\n\n    while(1) {\n        var protocol = that.protocol = that._protocols.shift();\n        if (!protocol) {\n            return false;\n        }\n        // Some protocols require access to `body`, what if were in\n        // the `head`?\n        if (SockJS[protocol] &&\n            SockJS[protocol].need_body === true &&\n            (!_document.body ||\n             (typeof _document.readyState !== 'undefined'\n              && _document.readyState !== 'complete'))) {\n            that._protocols.unshift(protocol);\n            that.protocol = 'waiting-for-load';\n            utils.attachEvent('load', function(){\n                that._try_next_protocol();\n            });\n            return true;\n        }\n\n        if (!SockJS[protocol] ||\n              !SockJS[protocol].enabled(that._options)) {\n            that._debug('Skipping transport:', protocol);\n        } else {\n            var roundTrips = SockJS[protocol].roundTrips || 1;\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\n            that._transport_tref = utils.delay(to, function() {\n                if (that.readyState === SockJS.CONNECTING) {\n                    // I can't understand how it is possible to run\n                    // this timer, when the state is CLOSED, but\n                    // apparently in IE everythin is possible.\n                    that._didClose(2007, \"Transport timeouted\");\n                }\n            });\n\n            var connid = utils.random_string(8);\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\n                        ' RTO:'+that._options.rto);\n            that._transport = new SockJS[protocol](that, trans_url,\n                                                   that._base_url);\n            return true;\n        }\n    }\n};\n\nSockJS.prototype.close = function(code, reason) {\n    var that = this;\n    if (code && !utils.userSetCode(code))\n        throw new Error(\"INVALID_ACCESS_ERR\");\n    if(that.readyState !== SockJS.CONNECTING &&\n       that.readyState !== SockJS.OPEN) {\n        return false;\n    }\n    that.readyState = SockJS.CLOSING;\n    that._didClose(code || 1000, reason || \"Normal closure\");\n    return true;\n};\n\nSockJS.prototype.send = function(data) {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING)\n        throw new Error('INVALID_STATE_ERR');\n    if (that.readyState === SockJS.OPEN) {\n        that._transport.doSend(utils.quote('' + data));\n    }\n    return true;\n};\n\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\n    var that = this;\n    that._options.info = info;\n    that._options.rtt = rtt;\n    that._options.rto = utils.countRTO(rtt);\n    that._options.info.null_origin = !_document.domain;\n    var probed = utils.probeProtocols();\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\n};\n//         [*] End of lib/sockjs.js\n\n\n//         [*] Including lib/trans-websocket.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\n    var that = this;\n    var url = trans_url + '/websocket';\n    if (url.slice(0, 5) === 'https') {\n        url = 'wss' + url.slice(5);\n    } else {\n        url = 'ws' + url.slice(4);\n    }\n    that.ri = ri;\n    that.url = url;\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\n\n    that.ws = new Constructor(that.url);\n    that.ws.onmessage = function(e) {\n        that.ri._didMessage(e.data);\n    };\n    // Firefox has an interesting bug. If a websocket connection is\n    // created after onbeforeunload, it stays alive even when user\n    // navigates away from the page. In such situation let's lie -\n    // let's not open the ws connection at all. See:\n    // https://github.com/sockjs/sockjs-client/issues/28\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\n    that.ws.onclose = function() {\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n    };\n};\n\nWebSocketTransport.prototype.doSend = function(data) {\n    this.ws.send('[' + data + ']');\n};\n\nWebSocketTransport.prototype.doCleanup = function() {\n    var that = this;\n    var ws = that.ws;\n    if (ws) {\n        ws.onmessage = ws.onclose = null;\n        ws.close();\n        utils.unload_del(that.unload_ref);\n        that.unload_ref = that.ri = that.ws = null;\n    }\n};\n\nWebSocketTransport.enabled = function() {\n    return !!(_window.WebSocket || _window.MozWebSocket);\n};\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n//         [*] End of lib/trans-websocket.js\n\n\n//         [*] Including lib/trans-sender.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar BufferedSender = function() {};\nBufferedSender.prototype.send_constructor = function(sender) {\n    var that = this;\n    that.send_buffer = [];\n    that.sender = sender;\n};\nBufferedSender.prototype.doSend = function(message) {\n    var that = this;\n    that.send_buffer.push(message);\n    if (!that.send_stop) {\n        that.send_schedule();\n    }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.send_schedule_wait = function() {\n    var that = this;\n    var tref;\n    that.send_stop = function() {\n        that.send_stop = null;\n        clearTimeout(tref);\n    };\n    tref = utils.delay(25, function() {\n        that.send_stop = null;\n        that.send_schedule();\n    });\n};\n\nBufferedSender.prototype.send_schedule = function() {\n    var that = this;\n    if (that.send_buffer.length > 0) {\n        var payload = '[' + that.send_buffer.join(',') + ']';\n        that.send_stop = that.sender(that.trans_url,\n                                     payload,\n                                     function() {\n                                         that.send_stop = null;\n                                         that.send_schedule_wait();\n                                     });\n        that.send_buffer = [];\n    }\n};\n\nBufferedSender.prototype.send_destructor = function() {\n    var that = this;\n    if (that._send_stop) {\n        that._send_stop();\n    }\n    that._send_stop = null;\n};\n\nvar jsonPGenericSender = function(url, payload, callback) {\n    var that = this;\n\n    if (!('_send_form' in that)) {\n        var form = that._send_form = _document.createElement('form');\n        var area = that._send_area = _document.createElement('textarea');\n        area.name = 'd';\n        form.style.display = 'none';\n        form.style.position = 'absolute';\n        form.method = 'POST';\n        form.enctype = 'application/x-www-form-urlencoded';\n        form.acceptCharset = \"UTF-8\";\n        form.appendChild(area);\n        _document.body.appendChild(form);\n    }\n    var form = that._send_form;\n    var area = that._send_area;\n    var id = 'a' + utils.random_string(8);\n    form.target = id;\n    form.action = url + '/jsonp_send?i=' + id;\n\n    var iframe;\n    try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');\n    } catch(x) {\n        iframe = _document.createElement('iframe');\n        iframe.name = id;\n    }\n    iframe.id = id;\n    form.appendChild(iframe);\n    iframe.style.display = 'none';\n\n    try {\n        area.value = payload;\n    } catch(e) {\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\n    }\n    form.submit();\n\n    var completed = function(e) {\n        if (!iframe.onerror) return;\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n        // Opera mini doesn't like if we GC iframe\n        // immediately, thus this timeout.\n        utils.delay(500, function() {\n                       iframe.parentNode.removeChild(iframe);\n                       iframe = null;\n                   });\n        area.value = '';\n        callback();\n    };\n    iframe.onerror = iframe.onload = completed;\n    iframe.onreadystatechange = function(e) {\n        if (iframe.readyState == 'complete') completed();\n    };\n    return completed;\n};\n\nvar createAjaxSender = function(AjaxObject) {\n    return function(url, payload, callback) {\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n        xo.onfinish = function(status, text) {\n            callback(status);\n        };\n        return function(abort_reason) {\n            callback(0, abort_reason);\n        };\n    };\n};\n//         [*] End of lib/trans-sender.js\n\n\n//         [*] Including lib/trans-jsonp-receiver.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Parts derived from Socket.io:\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n// and jQuery-JSONP:\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\nvar jsonPGenericReceiver = function(url, callback) {\n    var tref;\n    var script = _document.createElement('script');\n    var script2;  // Opera synchronous load trick.\n    var close_script = function(frame) {\n        if (script2) {\n            script2.parentNode.removeChild(script2);\n            script2 = null;\n        }\n        if (script) {\n            clearTimeout(tref);\n            script.parentNode.removeChild(script);\n            script.onreadystatechange = script.onerror =\n                script.onload = script.onclick = null;\n            script = null;\n            callback(frame);\n            callback = null;\n        }\n    };\n\n    // IE9 fires 'error' event after orsc or before, in random order.\n    var loaded_okay = false;\n    var error_timer = null;\n\n    script.id = 'a' + utils.random_string(8);\n    script.src = url;\n    script.type = 'text/javascript';\n    script.charset = 'UTF-8';\n    script.onerror = function(e) {\n        if (!error_timer) {\n            // Delay firing close_script.\n            error_timer = setTimeout(function() {\n                if (!loaded_okay) {\n                    close_script(utils.closeFrame(\n                        1006,\n                        \"JSONP script loaded abnormally (onerror)\"));\n                }\n            }, 1000);\n        }\n    };\n    script.onload = function(e) {\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n    };\n\n    script.onreadystatechange = function(e) {\n        if (/loaded|closed/.test(script.readyState)) {\n            if (script && script.htmlFor && script.onclick) {\n                loaded_okay = true;\n                try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                } catch (x) {}\n            }\n            if (script) {\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n            }\n        }\n    };\n    // IE: event/htmlFor/onclick trick.\n    // One can't rely on proper order for onreadystatechange. In order to\n    // make sure, set a 'htmlFor' and 'event' properties, so that\n    // script code will be installed as 'onclick' handler for the\n    // script object. Later, onreadystatechange, manually execute this\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n    // set. For reference see:\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n    // Also, read on that about script ordering:\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\n        // According to mozilla docs, in recent browsers script.async defaults\n        // to 'true', so we may use it to detect a good browser:\n        // https://developer.mozilla.org/en/HTML/Element/script\n        if (!/opera/i.test(navigator.userAgent)) {\n            // Naively assume we're in IE\n            try {\n                script.htmlFor = script.id;\n                script.event = \"onclick\";\n            } catch (x) {}\n            script.async = true;\n        } else {\n            // Opera, second sync script hack\n            script2 = _document.createElement('script');\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;\n        }\n    }\n    if (typeof script.async !== 'undefined') {\n        script.async = true;\n    }\n\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n    tref = setTimeout(function() {\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                      }, 35000);\n\n    var head = _document.getElementsByTagName('head')[0];\n    head.insertBefore(script, head.firstChild);\n    if (script2) {\n        head.insertBefore(script2, head.firstChild);\n    }\n    return close_script;\n};\n//         [*] End of lib/trans-jsonp-receiver.js\n\n\n//         [*] Including lib/trans-jsonp-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// mssage could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\n\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\n    utils.polluteGlobalNamespace();\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(jsonPGenericSender);\n    that._schedule_recv();\n};\n\n// Inheritnace\nJsonPTransport.prototype = new BufferedSender();\n\nJsonPTransport.prototype._schedule_recv = function() {\n    var that = this;\n    var callback = function(data) {\n        that._recv_stop = null;\n        if (data) {\n            // no data - heartbeat;\n            if (!that._is_closing) {\n                that.ri._didMessage(data);\n            }\n        }\n        // The message can be a close message, and change is_closing state.\n        if (!that._is_closing) {\n            that._schedule_recv();\n        }\n    };\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\n                                           jsonPGenericReceiver, callback);\n};\n\nJsonPTransport.enabled = function() {\n    return true;\n};\n\nJsonPTransport.need_body = true;\n\n\nJsonPTransport.prototype.doCleanup = function() {\n    var that = this;\n    that._is_closing = true;\n    if (that._recv_stop) {\n        that._recv_stop();\n    }\n    that.ri = that._recv_stop = null;\n    that.send_destructor();\n};\n\n\n// Abstract away code that handles global namespace pollution.\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\n    var id = 'a' + utils.random_string(6);\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\n    // Callback will be called exactly once.\n    var callback = function(frame) {\n        delete _window[WPrefix][id];\n        user_callback(frame);\n    };\n\n    var close_script = constructReceiver(url_id, callback);\n    _window[WPrefix][id] = close_script;\n    var stop = function() {\n        if (_window[WPrefix][id]) {\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n        }\n    };\n    return stop;\n};\n//         [*] End of lib/trans-jsonp-polling.js\n\n\n//         [*] Including lib/trans-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AjaxBasedTransport = function() {};\nAjaxBasedTransport.prototype = new BufferedSender();\n\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\n                                            url_suffix, Receiver, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(createAjaxSender(AjaxObject));\n    that.poll = new Polling(ri, Receiver,\n                            trans_url + url_suffix, AjaxObject);\n};\n\nAjaxBasedTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.poll) {\n        that.poll.abort();\n        that.poll = null;\n    }\n};\n\n// xhr-streaming\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXhrStreamingTransport.enabled = function() {\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n    // doesn't do streaming.\n    return (_window.XMLHttpRequest &&\n            'withCredentials' in new XMLHttpRequest() &&\n            (!/opera/i.test(navigator.userAgent)));\n};\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\nXhrStreamingTransport.need_body = true;\n\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n\n// xdr-streaming\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n};\n\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXdrStreamingTransport.enabled = function() {\n    return !!_window.XDomainRequest;\n};\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n\n\n// xhr-polling\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrPollingTransport.prototype = new AjaxBasedTransport();\n\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n\n// xdr-polling\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n};\n\nXdrPollingTransport.prototype = new AjaxBasedTransport();\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n//         [*] End of lib/trans-xhr.js\n\n\n//         [*] Including lib/trans-iframe.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Few cool transports do work only for same-origin. In order to make\n// them working cross-domain we shall use iframe, served form the\n// remote domain. New browsers, have capabilities to communicate with\n// cross domain iframe, using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar IframeTransport = function() {};\n\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\n    var that = this;\n    that.ri = ri;\n    that.origin = utils.getOrigin(base_url);\n    that.base_url = base_url;\n    that.trans_url = trans_url;\n\n    var iframe_url = base_url + '/iframe.html';\n    if (that.ri._options.devel) {\n        iframe_url += '?t=' + (+new Date);\n    }\n    that.window_id = utils.random_string(8);\n    iframe_url += '#' + that.window_id;\n\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                                        });\n\n    that.onmessage_cb = utils.bind(that.onmessage, that);\n    utils.attachMessage(that.onmessage_cb);\n};\n\nIframeTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.iframeObj) {\n        utils.detachMessage(that.onmessage_cb);\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (that.iframeObj.iframe.contentWindow) {\n                that.postMessage('c');\n            }\n        } catch (x) {}\n        that.iframeObj.cleanup();\n        that.iframeObj = null;\n        that.onmessage_cb = that.iframeObj = null;\n    }\n};\n\nIframeTransport.prototype.onmessage = function(e) {\n    var that = this;\n    if (e.origin !== that.origin) return;\n    var window_id = e.data.slice(0, 8);\n    var type = e.data.slice(8, 9);\n    var data = e.data.slice(9);\n\n    if (window_id !== that.window_id) return;\n\n    switch(type) {\n    case 's':\n        that.iframeObj.loaded();\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n        break;\n    case 't':\n        that.ri._didMessage(data);\n        break;\n    }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n    var that = this;\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n};\n\nIframeTransport.prototype.doSend = function (message) {\n    this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n    // huge delay, or not at all.\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n    return ((typeof _window.postMessage === 'function' ||\n            typeof _window.postMessage === 'object') && (!konqueror));\n};\n//         [*] End of lib/trans-iframe.js\n\n\n//         [*] Including lib/trans-iframe-within.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar curr_window_id;\n\nvar postMessage = function (type, data) {\n    if(parent !== _window) {\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\n    } else {\n        utils.log(\"Can't postMessage, no parent window.\", type, data);\n    }\n};\n\nvar FacadeJS = function() {};\nFacadeJS.prototype._didClose = function (code, reason) {\n    postMessage('t', utils.closeFrame(code, reason));\n};\nFacadeJS.prototype._didMessage = function (frame) {\n    postMessage('t', frame);\n};\nFacadeJS.prototype._doSend = function (data) {\n    this._transport.doSend(data);\n};\nFacadeJS.prototype._doCleanup = function () {\n    this._transport.doCleanup();\n};\n\nutils.parent_origin = undefined;\n\nSockJS.bootstrap_iframe = function() {\n    var facade;\n    curr_window_id = _document.location.hash.slice(1);\n    var onMessage = function(e) {\n        if(e.source !== parent) return;\n        if(typeof utils.parent_origin === 'undefined')\n            utils.parent_origin = e.origin;\n        if (e.origin !== utils.parent_origin) return;\n\n        var window_id = e.data.slice(0, 8);\n        var type = e.data.slice(8, 9);\n        var data = e.data.slice(9);\n        if (window_id !== curr_window_id) return;\n        switch(type) {\n        case 's':\n            var p = JSON.parse(data);\n            var version = p[0];\n            var protocol = p[1];\n            var trans_url = p[2];\n            var base_url = p[3];\n            if (version !== SockJS.version) {\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +\n                          \" \\\"\" + version + \"\\\", the iframe:\" +\n                          \" \\\"\" + SockJS.version + \"\\\".\");\n            }\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                utils.log(\"Only basic urls are supported in SockJS\");\n                return;\n            }\n\n            if (!utils.isSameOriginUrl(trans_url) ||\n                !utils.isSameOriginUrl(base_url)) {\n                utils.log(\"Can't connect to different domain from within an \" +\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\n                          \")\");\n                return;\n            }\n            facade = new FacadeJS();\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n            break;\n        case 'm':\n            facade._doSend(data);\n            break;\n        case 'c':\n            if (facade)\n                facade._doCleanup();\n            facade = null;\n            break;\n        }\n    };\n\n    // alert('test ticker');\n    // facade = new FacadeJS();\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n    utils.attachMessage(onMessage);\n\n    // Start\n    postMessage('s');\n};\n//         [*] End of lib/trans-iframe-within.js\n\n\n//         [*] Including lib/info.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar InfoReceiver = function(base_url, AjaxObject) {\n    var that = this;\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\n};\n\nInfoReceiver.prototype = new EventEmitter(['finish']);\n\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\n    var that = this;\n    var t0 = (new Date()).getTime();\n    var xo = new AjaxObject('GET', base_url + '/info');\n\n    var tref = utils.delay(8000,\n                           function(){xo.ontimeout();});\n\n    xo.onfinish = function(status, text) {\n        clearTimeout(tref);\n        tref = null;\n        if (status === 200) {\n            var rtt = (new Date()).getTime() - t0;\n            var info = JSON.parse(text);\n            if (typeof info !== 'object') info = {};\n            that.emit('finish', info, rtt);\n        } else {\n            that.emit('finish');\n        }\n    };\n    xo.ontimeout = function() {\n        xo.close();\n        that.emit('finish');\n    };\n};\n\nvar InfoReceiverIframe = function(base_url) {\n    var that = this;\n    var go = function() {\n        var ifr = new IframeTransport();\n        ifr.protocol = 'w-iframe-info-receiver';\n        var fun = function(r) {\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\n                var d = JSON.parse(r.substr(1));\n                var info = d[0], rtt = d[1];\n                that.emit('finish', info, rtt);\n            } else {\n                that.emit('finish');\n            }\n            ifr.doCleanup();\n            ifr = null;\n        };\n        var mock_ri = {\n            _options: {},\n            _didClose: fun,\n            _didMessage: fun\n        };\n        ifr.i_constructor(mock_ri, base_url, base_url);\n    }\n    if(!_document.body) {\n        utils.attachEvent('load', go);\n    } else {\n        go();\n    }\n};\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n\nvar InfoReceiverFake = function() {\n    // It may not be possible to do cross domain AJAX to get the info\n    // data, for example for IE7. But we want to run JSONP, so let's\n    // fake the response, with rtt=2s (rto=6s).\n    var that = this;\n    utils.delay(function() {\n        that.emit('finish', {}, 2000);\n    });\n};\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\n\nvar createInfoReceiver = function(base_url) {\n    if (utils.isSameOriginUrl(base_url)) {\n        // If, for some reason, we have SockJS locally - there's no\n        // need to start up the complex machinery. Just use ajax.\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    }\n    switch (utils.isXHRCorsCapable()) {\n    case 1:\n        return new InfoReceiver(base_url, utils.XHRCorsObject);\n    case 2:\n        return new InfoReceiver(base_url, utils.XDRObject);\n    case 3:\n        // Opera\n        return new InfoReceiverIframe(base_url);\n    default:\n        // IE 7\n        return new InfoReceiverFake();\n    };\n};\n\n\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n    ir.onfinish = function(info, rtt) {\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\n        ri._didClose();\n    }\n};\nWInfoReceiverIframe.prototype.doCleanup = function() {};\n//         [*] End of lib/info.js\n\n\n//         [*] Including lib/trans-iframe-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-eventsource';\n    that.i_constructor.apply(that, arguments);\n};\n\nEventSourceIframeTransport.prototype = new IframeTransport();\n\nEventSourceIframeTransport.enabled = function () {\n    return ('EventSource' in _window) && IframeTransport.enabled();\n};\n\nEventSourceIframeTransport.need_body = true;\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n\n\n// w-iframe-eventsource\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n}\nEventSourceTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-eventsource.js\n\n\n//         [*] Including lib/trans-iframe-xhr-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-xhr-polling';\n    that.i_constructor.apply(that, arguments);\n};\n\nXhrPollingIframeTransport.prototype = new IframeTransport();\n\nXhrPollingIframeTransport.enabled = function () {\n    return _window.XMLHttpRequest && IframeTransport.enabled();\n};\n\nXhrPollingIframeTransport.need_body = true;\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n\n\n// w-iframe-xhr-polling\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n};\n\nXhrPollingITransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-xhr-polling.js\n\n\n//         [*] Including lib/trans-iframe-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// This transport generally works in any browser, but will cause a\n// spinning cursor to appear in any browser other than IE.\n// We may test this transport in all browsers - why not, but in\n// production it should be only run in IE.\n\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-htmlfile';\n    that.i_constructor.apply(that, arguments);\n};\n\n// Inheritance.\nHtmlFileIframeTransport.prototype = new IframeTransport();\n\nHtmlFileIframeTransport.enabled = function() {\n    return IframeTransport.enabled();\n};\n\nHtmlFileIframeTransport.need_body = true;\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n\n\n// w-iframe-htmlfile\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n};\nHtmlFileTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-htmlfile.js\n\n\n//         [*] Including lib/trans-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.Receiver = Receiver;\n    that.recv_url = recv_url;\n    that.AjaxObject = AjaxObject;\n    that._scheduleRecv();\n};\n\nPolling.prototype._scheduleRecv = function() {\n    var that = this;\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n    var msg_counter = 0;\n    poll.onmessage = function(e) {\n        msg_counter += 1;\n        that.ri._didMessage(e.data);\n    };\n    poll.onclose = function(e) {\n        that.poll = poll = poll.onmessage = poll.onclose = null;\n        if (!that.poll_is_closing) {\n            if (e.reason === 'permanent') {\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n            } else {\n                that._scheduleRecv();\n            }\n        }\n    };\n};\n\nPolling.prototype.abort = function() {\n    var that = this;\n    that.poll_is_closing = true;\n    if (that.poll) {\n        that.poll.abort();\n    }\n};\n//         [*] End of lib/trans-polling.js\n\n\n//         [*] Including lib/trans-receiver-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceReceiver = function(url) {\n    var that = this;\n    var es = new EventSource(url);\n    es.onmessage = function(e) {\n        that.dispatchEvent(new SimpleEvent('message',\n                                           {'data': unescape(e.data)}));\n    };\n    that.es_close = es.onerror = function(e, abort_reason) {\n        // ES on reconnection has readyState = 0 or 1.\n        // on network error it's CLOSED = 2\n        var reason = abort_reason ? 'user' :\n            (es.readyState !== 2 ? 'network' : 'permanent');\n        that.es_close = es.onmessage = es.onerror = null;\n        // EventSource reconnects automatically.\n        es.close();\n        es = null;\n        // Safari and chrome < 15 crash if we close window before\n        // waiting for ES cleanup. See:\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\n        utils.delay(200, function() {\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n                    });\n    };\n};\n\nEventSourceReceiver.prototype = new REventTarget();\n\nEventSourceReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.es_close) {\n        that.es_close({}, true);\n    }\n};\n//         [*] End of lib/trans-receiver-eventsource.js\n\n\n//         [*] Including lib/trans-receiver-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar _is_ie_htmlfile_capable;\nvar isIeHtmlfileCapable = function() {\n    if (_is_ie_htmlfile_capable === undefined) {\n        if ('ActiveXObject' in _window) {\n            try {\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n            } catch (x) {}\n        } else {\n            _is_ie_htmlfile_capable = false;\n        }\n    }\n    return _is_ie_htmlfile_capable;\n};\n\n\nvar HtmlfileReceiver = function(url) {\n    var that = this;\n    utils.polluteGlobalNamespace();\n\n    that.id = 'a' + utils.random_string(6, 26);\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\n        'c=' + escape(WPrefix + '.' + that.id);\n\n    var constructor = isIeHtmlfileCapable() ?\n        utils.createHtmlfile : utils.createIframe;\n\n    var iframeObj;\n    _window[WPrefix][that.id] = {\n        start: function () {\n            iframeObj.loaded();\n        },\n        message: function (data) {\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\n        },\n        stop: function () {\n            that.iframe_close({}, 'network');\n        }\n    };\n    that.iframe_close = function(e, abort_reason) {\n        iframeObj.cleanup();\n        that.iframe_close = iframeObj = null;\n        delete _window[WPrefix][that.id];\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\n    };\n    iframeObj = constructor(url, function(e) {\n                                that.iframe_close({}, 'permanent');\n                            });\n};\n\nHtmlfileReceiver.prototype = new REventTarget();\n\nHtmlfileReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.iframe_close) {\n        that.iframe_close({}, 'user');\n    }\n};\n//         [*] End of lib/trans-receiver-htmlfile.js\n\n\n//         [*] Including lib/trans-receiver-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrReceiver = function(url, AjaxObject) {\n    var that = this;\n    var buf_pos = 0;\n\n    that.xo = new AjaxObject('POST', url, null);\n    that.xo.onchunk = function(status, text) {\n        if (status !== 200) return;\n        while (1) {\n            var buf = text.slice(buf_pos);\n            var p = buf.indexOf('\\n');\n            if (p === -1) break;\n            buf_pos += p+1;\n            var msg = buf.slice(0, p);\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\n        }\n    };\n    that.xo.onfinish = function(status, text) {\n        that.xo.onchunk(status, text);\n        that.xo = null;\n        var reason = status === 200 ? 'network' : 'permanent';\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n    }\n};\n\nXhrReceiver.prototype = new REventTarget();\n\nXhrReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.xo) {\n        that.xo.close();\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\n        that.xo = null;\n    }\n};\n//         [*] End of lib/trans-receiver-xhr.js\n\n\n//         [*] Including lib/test-hooks.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// For testing\nSockJS.getUtils = function(){\n    return utils;\n};\n\nSockJS.getIframeTransport = function(){\n    return IframeTransport;\n};\n//         [*] End of lib/test-hooks.js\n\n                  return SockJS;\n          })();\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\n\n// AMD compliance\nif (typeof define === 'function' && define.amd) {\n    define('sockjs', [], function(){return SockJS;});\n}\n\nif (typeof module === 'object' && module && module.exports) {\n    module.exports = SockJS;\n}\n//     [*] End of lib/index.js\n\n// [*] End of lib/all.js\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/sockjs.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/inject.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = opts || {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      emitter.on('connect', onConnect)\n\n    var backoffMethod = (backoff[opts.type] || backoff.fibonacci) (opts)\n\n    backoffMethod.on('backoff', function (n, d) {\n      emitter.emit('backoff', n, d)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(emitter.connected) return\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(null, args)\n      emitter._connection = con\n      \n      function onDisconnect () {\n        emitter.connected = false\n        con.removeListener('error', onDisconnect)\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if(con.constructor.name == 'Request')\n          con.on('error', function () {})\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', con)\n\n        if(!emitter.reconnect) return\n        backoffMethod.backoff()\n      }\n\n      con\n        .on('error', onDisconnect)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n\n      if(con.constructor.name == 'Request') {\n        emitter.connected = true\n        emitter.emit('connect', con)\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset()\n        })\n      } else {\n        con\n          .on('connect', function () {\n            backoffMethod.reset()\n            emitter.connected = true\n            con.removeListener('connect', onConnect)\n            emitter.emit('connect', con)\n          })\n      }\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      args = [].slice.call(arguments)\n      attempt(0, 0)\n      return emitter\n    }\n\n    //force reconnection\n    emitter.reconnect = function () {\n      if(this.connected)\n        return emitter.disconnect()\n      \n      backoffMethod.reset()\n      attempt(0, 0)\n      return emitter\n    }\n\n    emitter.disconnect = function () {\n      this.reconnect = false\n      if(!emitter.connected) return emitter\n      \n      else if(emitter._connection)\n        emitter._connection.destroy()\n\n      emitter.emit('disconnect')\n      return emitter\n    }\n\n    var widget\n    emitter.widget = function () {\n      if(!widget)\n        widget = require('./widget')(emitter)\n      return widget\n    }\n\n    return emitter\n  }\n\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/inject.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/package.json"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar Backoff = require('./lib/backoff'),\n    FibonacciBackoffStrategy = require('./lib/strategy/fibonacci'),\n    ExponentialBackoffStrategy = require('./lib/strategy/exponential');\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n/**\n * Constructs a Fibonacci backoff.\n * @param options Fibonacci backoff strategy arguments.\n * @see FibonacciBackoffStrategy\n */\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n/**\n * Constructs an exponential backoff.\n * @param options Exponential strategy arguments.\n * @see ExponentialBackoffStrategy\n */\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/index.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/backoff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\n/**\n * Backoff driver.\n * @param backoffStrategy Backoff delay generator/strategy.\n * @constructor\n */\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n/**\n * Starts a backoff operation.\n */\nBackoff.prototype.backoff = function() {\n    if (this.timeoutID_ !== -1) {\n        throw new Error('Backoff in progress.');\n    }\n\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_);\n};\n\n/**\n * Backoff completion handler.\n * @private\n */\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_++, this.backoffDelay_);\n};\n\n/**\n * Stops any backoff operation and resets the backoff\n * delay to its inital value.\n */\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/backoff.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Fibonacci backoff strategy.\n * @extends BackoffStrategy\n */\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay.\n */\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay.\n */\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n/**\n * Template method that resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n/**\n * Resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Exponential backoff strategy.\n * @extends BackoffStrategy\n */\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * 2;\n    return this.backoffDelay_;\n};\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar h = require('h')\n\nmodule.exports = function (emitter) {\n  var style = {}\n  var el = h('a', {\n    href: '#', \n    style: style, \n    click: function () {\n      emitter.connected \n        ? emitter.disconnect()\n        : emitter.reconnect()\n    }\n  })\n  var int\n  emitter.on('reconnect', function (n, d) {\n    var delay = Math.round(d / 1000) + 1\n    console.log(n, d)\n    el.innerText = 'reconnect in ' + delay\n    clearInterval(int)\n    int = setInterval(function () {\n      el.innerText = delay ? 'reconnect in ' + --delay : 'reconnecting...'\n    }, 1e3)\n  })\n  emitter.on('connect',   function () {\n    el.innerText = 'connected'\n    clearInterval(int)\n  })\n  return el\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/widget.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/h/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/h/package.json"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/h/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\nfunction h() {\n  var args = [].slice.call(arguments), e = null\n  function item (l) {\n    \n    function parseClass (string) {\n      var m = string.split(/([\\.#]?[a-zA-Z0-9_-]+)/)\n      m.forEach(function (v) {\n        var s = v.substring(1,v.length)\n        if(!v) return \n        if(!e)\n          e = document.createElement(v)\n        else if (v[0] === '.')\n          e.classList.add(s)\n        else if (v[0] === '#')\n          e.setAttribute('id', s)\n        \n      })\n    }\n\n    if(l == null)\n      ;\n    else if('string' === typeof l) {\n      if(!e)\n        parseClass(l)\n      else\n        e.appendChild(document.createTextNode(l))\n    }\n    else if('number' === typeof l \n      || 'boolean' === typeof l\n      || l instanceof Date \n      || l instanceof RegExp ) {\n        e.appendChild(document.createTextNode(l.toString()))\n    }\n    else if (Array.isArray(l))\n      l.forEach(item)\n    else if(l instanceof HTMLElement)\n      e.appendChild(l)\n    else if ('object' === typeof l) {\n      for (var k in l) {\n        if('function' === typeof l[k])\n          e.addEventListener(k, l[k])\n        else if(k === 'style') {\n          for (var s in l[k])\n            e.style.setProperty(s, l[k][s])\n        }\n        else\n          e.setAttribute(k, l[k])\n      }\n    }\n  }\n  while(args.length) {\n    item(args.shift())\n  }\n  return e\n}\n\nif(typeof module === 'object')\n  module.exports = h\nelse\n  this.h = h\n})()\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/h/index.js"
));

require.define("/node_modules/rumours/node_modules/client-reloader/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/package.json"
));

require.define("/node_modules/rumours/node_modules/client-reloader/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar header = require('header-stream')\n\nvar version = 0\n/**\nTODO\nmore sophisticated reloading, \npass in a package and a semver range...\n**/\nmodule.exports = function (handler, init) {\n  return function (stream) {\n    var args = [].slice.call(arguments)\n    init = init || {}\n\n    init.version = version || 0\n    \n    header(stream)\n      .setHeader(init)\n      .writeHead()\n\n    stream.on('header', function (meta) {\n\n      if(!version)\n        version = meta.version\n      if(meta.version !== version && version !== 0) {\n        stream.emit('reload', meta.version, version)\n        stream.end()\n\n        return window.location.reload(true)\n      } else\n        version = meta.version\n\n      handler.apply(this, args)\n    })\n  }\n\n}\n/*\nvar wrap = function (stream, _version) {\n  version = _version || version\n  stream = header(stream)\n  stream.on('header', function (meta) {\n    //is it same version as last time?\n    if(!version)\n      version = meta.version\n    if(meta.version !== version) {\n      stream.emit('reload', meta.version, version)\n      stream.end()\n\n      window.location.reload(true)\n    }\n  })\n  return stream\n}\n*/\n\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/browser.js"
));

require.define("/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/package.json"
));

require.define("/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//the first line is header, in JSON format, with no whitespace.\n\nfunction merge (a, b) {\n  for (var k in b)\n    a[k] = a[k] || b[k]\n}\n\nmodule.exports = \nfunction header (stream) {\n\n  var emit = stream.emit\n  var write = stream.write\n  var soFar = ''\n\n  stream.emit = function (event, data) {\n    if(event !== 'data')\n      return emit.apply(stream, arguments)\n\n    soFar += data\n    var m\n    if(!(m = /\\n/.exec(soFar))) return\n    var meta = JSON.parse(soFar.substring(0, m.index))\n    //+ 1 to get past the newline\n    soFar = soFar.substring(m.index + 1)\n    stream.emit = emit\n    stream.meta = meta\n    stream.emit('header', meta)\n    //check that the stream is still readable,\n    //it may have been ended during the 'header'\n    //event.\n    if('' !== soFar  && stream.readable)\n      stream.emit('data', soFar)\n  }\n\n  var meta = {}\n\n  stream.setHeader = function (key, val) {\n    if('string' === typeof key)\n      meta[key] = val\n    else\n      merge(meta, key)\n    return stream\n  }\n\n  stream.writeHead = function (_meta) {\n    if(_meta) merge(meta, _meta)\n    stream.write = write\n    stream.write(JSON.stringify(meta)+'\\n')    \n  }\n\n  stream.write = function (data) {\n    stream.writeHead()\n    return stream.write(data)\n  }\n\n  return stream\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar Schema   = require('./lib/schema')\nvar Client   = require('./lib/client-opener')\nvar Buffered = require('./lib/buffered-opener')\n\nmodule.exports = function (schema) {\n  schema = Schema(schema)\n  var c = Client()\n  var b = Buffered(schema)\n  c.on('open', function () {\n    b.swap(c)\n  })\n  b.createStream = \n  b.createRemoteStream = c.createStream\n  return b\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/client.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var parserx = require('parse-regexp')\n\n//don't make the timeout too large, because it will prevent the process from exiting...\nvar exports = module.exports = function (schema) {\n  if('function' == typeof schema)\n    return schema\n\n  var rules = []\n  for (var p in schema) {\n    rules.push({rx: parserx(p) || p, fn: schema[p]})\n  }\n\n  function match (key) {\n    if('object' === typeof key) return key\n    for (var i in rules) {\n      var r = rules[i]\n      var m = key.match(r.rx)\n      if(m && m.index === 0) {\n        var scuttlebutt = r.fn(key)\n        scuttlebutt.name = key\n        return scuttlebutt\n      }\n    }\n  }\n\n  match.schema = schema\n  match.rules = rules\n\n  return match\n}\n\nexports.schema = exports\n\nexports.cache =\nfunction (schema, open, onCache) {\n  var local = cached.local = {}\n  function cached (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    //user *must not* pass a Scuttlebutt instance to cached open.\n    if('string' !== typeof name)\n      throw new Error('name must be string')\n\n    //so if this is passed a ready instance...\n    //and there is a cached instance... then pipe them together.\n    //hmm, but the caching should be ontop of the other layer...\n    //will this work?\n    //ah, if a scuttlebutt is passed, and there isn't one in the cache\n    //clone it and put the clone in the cache!\n    //else, pipe it to the cached instace.\n\n    //actually... should combine this into level-scuttlebutt\n    //then only one cache will be necessary.\n\n    //which will work better for reconnections.\n\n    //...so, need lots of tests here.\n\n    //yes, only one cache, the outer most open does not support\n    //opening with a scuttlebutt - but remote, and \n    //level-scuttlebutt do!\n    \n    //then there is only one cache...\n    //so, you always control the point of caching.\n    //no \"russian doll\" caching.\n\n    var cached = local[name]\n    if(cached && 'function' === typeof cached.clone) {\n      var n = cached.clone()\n      n.name = name\n      cb(null, n)\n      return n\n    }\n    var clone\n    var scuttlebutt = local[name] = schema(name)\n    scuttlebutt.name = name\n    open(scuttlebutt, tail, function (err, scuttlebutt) {\n      if(err) return cb(err)\n      cb(null, clone)\n    })\n\n    //will callback an error\n    if(!scuttlebutt) return\n\n    scuttlebutt.name = name\n    \n    //only scuttlebutts with clone can be cleanly cached.\n    if('function' === typeof scuttlebutt.clone) {\n      local[name] = scuttlebutt\n      clone = scuttlebutt.clone()\n      clone.name = name\n      if(onCache) onCache('clone', scuttlebutt.name)\n      //okay... have something to dispose the scuttlebutt when there are 0 streams.\n      //hmm, count streams... and emit an event 'unstream' or something?\n      //okay, if all the steams have closed but this one, then it means no one is using this,\n      //so close...\n      //TODO add this to level-scuttlebutt.\n\n      //OH, hang on... maybe DOMAINS is the right thing to use here...\n\n      var timer = null\n      scuttlebutt.on('unstream', function (n) {\n        if(n === 1) {\n          clearTimeout(timer)\n          timer = setTimeout(function () {\n            scuttlebutt.dispose()\n            if(onCache) onCache('uncache', scuttlebutt.name)\n          }, TIMEOUT*1.5)\n            //if an emitter was passed, imet\n        } else if(n > 1)\n          clearTimeout(timer)\n      })\n      scuttlebutt.on('dispose', function () {\n        delete local[name]\n      })\n    }\n    \n    return scuttlebutt\n  }\n\n  return cached\n}\n\nexports.sync = \nexports.open = function (schema, connect) {\n  //pass in a string name, or a scuttlebutt instance\n  //you want to reconnect to the server.\n  return function (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    if('string' === typeof name)\n      throw new Error('expect cache to create Scuttlebutt for open')\n\n    var scuttlebutt = name\n    /*\n    if('string' === typeof name)\n      scuttlebutt = schema(name)\n    else {\n      scuttlebutt = name\n      name = scuttlebutt.name\n    }\n    */\n    var es = scuttlebutt.createStream()\n    var stream = connect(scuttlebutt.name)\n\n    if(!stream)\n      return cb(new Error('unable to connect'))\n\n    stream.pipe(es).pipe(stream)\n\n    var ready = false\n    es.once('sync', function () {\n      if(ready) return\n      ready = true\n\n      //cb the stream we are loading the scuttlebutt from,\n      //incase it errors after we cb?\n      //I'm not sure about this usecase.\n      //Actually, just leave that feature out!\n      //that way I don't have to break API when I realize it was a bad idea.\n      if(cb)    cb(null, scuttlebutt)\n      if(!tail) es.end()\n    })\n    //hmm, this has no way to detect that the stream has errored\n    stream.once('error', function (err) {\n      if(!ready) return cb(err)\n    })\n\n    return scuttlebutt\n  }\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/schema.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var rx = /^\\/((?:\\\\\\/|[^\\/])+)\\/(.*)$/\nmodule.exports = function (string) {\n  var m = rx.exec(string)\n  return m ? new RegExp(m[1], m[2]) : null\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/client-opener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar MuxDemux     = require('mux-demux')\nvar remoteOpen = function (connect) {\n  //pass in a string name, or a scuttlebutt instance\n  //you want to reconnect to the server.\n  return function (scuttlebutt, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    if('object' !== typeof scuttlebutt)\n      throw new Error('expect Scuttlebutt, not ' + typeof scuttlebutt)\n\n    var es = scuttlebutt.createStream(), stream\n    try {\n      stream = connect(scuttlebutt.name)\n    } catch (err) { return cb(err) }\n\n    if(!stream)\n      return cb(new Error('unable to connect'))\n\n    stream.pipe(es).pipe(stream)\n\n    var ready = false\n    es.once('sync', function () {\n      if(ready) return\n      ready = true\n\n      //cb the stream we are loading the scuttlebutt from,\n      //incase it errors after we cb?\n      //I'm not sure about this usecase.\n      //Actually, just leave that feature out!\n      //that way I don't have to break API when I realize it was a bad idea.\n      if(cb)    cb(null, scuttlebutt)\n      if(!tail) es.end()\n    })\n    //hmm, this has no way to detect that the stream has errored\n    stream.once('error', function (err) {\n      if(!ready) return cb(err)\n    })\n\n    return scuttlebutt\n  }\n}\n\nmodule.exports = function () {\n\n  var opener = new EventEmitter()\n  var mx = null\n\n  opener.open = remoteOpen(function (name) {\n    if(!mx) throw new Error('scuttlebutt remoteOpener must be connected')\n    return mx.createStream(name)\n  })\n\n  opener.view = function () {\n    var args = [].slice.call(arguments)\n  }\n\n  //create stream...\n  opener.createStream = function () {\n    if(mx) throw new Error('remoteOpener may only connect to one server')\n\n    mx = MuxDemux(function (stream) {\n      stream.error(new Error('remoteOpener is client only - cannot recieve stream'))\n    })\n\n    mx.on('close', function () {\n      mx.removeAllListeners()\n      mx = null\n      opener.emit('close')\n    })\n\n    /*mx.pause()\n    process.nextTick(function () {\n      mx.resume()\n    })*/\n    process.nextTick(function () {\n      opener.emit('open', mx)\n      mx.resume()\n    })\n    return mx\n  }\n\n  return opener\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/client-opener.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\n\nvar through = require('through')\n  , extend = require('xtend')\n  , duplex = require('duplex')\n  , serializer = require('stream-serializer')\n\nfunction MuxDemux (opts, onConnection) {\n  if('function' === typeof opts)\n    onConnection = opts, opts = null\n  opts = opts || {}\n\n  function createID() {\n    return (\n      Math.random().toString(16).slice(2) +\n      Math.random().toString(16).slice(2)\n    )\n  }\n\n  var streams = {}, streamCount = 0\n  var md = duplex().resume()\n\n  md.on('_data', function (data) {\n    var id = data.shift()\n    var event = data[0]\n    var s = streams[id]\n    if(!s) {\n      if(event == 'close')\n        return\n      if(event != 'new')\n        return outer.emit('unknown', id)\n      md.emit('connection', createStream(id, data[1].meta, data[1].opts))\n    }\n    else if (event === 'pause')\n      s.paused = true\n    else if (event === 'resume') {\n      var p = s.paused\n      s.paused = false\n      if(p) s.emit('drain')\n    }\n    else if (event === 'error') {\n      var error = data[1]\n      if (typeof error === 'string') {\n        s.emit('error', new Error(error))\n      } else if (typeof error.message === 'string') {\n        var e = new Error(error.message)\n        extend(e, error)\n        s.emit('error', e)\n      } else {\n        s.emit('error', error)\n      }\n    }\n    else {\n      s.emit.apply(s, data)\n    }\n  })\n\n  function destroyAll (_err) {\n    md.removeListener('end', destroyAll)\n    md.removeListener('error', destroyAll)\n    md.removeListener('close', destroyAll)\n    var err = _err || new Error ('unexpected disconnection')\n    for (var i in streams) {\n      var s = streams[i]\n      s.destroyed = true\n      if (opts.error !== true) {\n        s.end()\n      } else {\n        s.emit('error', err)\n        s.destroy()\n      }\n    }\n  }\n\n  //end the stream once sub-streams have ended.\n  //(waits for them to close, like on a tcp server)\n\n  function createStream(id, meta, opts) {\n    streamCount ++\n    var s = through(function (data) {\n      if(!this.writable) {\n        var err = Error('stream is not writable: ' + id)\n        err.stream = this\n        return outer.emit(\"error\", err)\n      }\n\n      md._data([s.id, 'data', data])\n    }, function () {\n      md._data([s.id, 'end'])\n      if (this.readable && !opts.allowHalfOpen && !this.ended) {\n        this.emit(\"end\")\n      }\n    })\n    s.pause = function () {\n      md._data([s.id, 'pause'])\n    }\n    s.resume = function () {\n      md._data([s.id, 'resume'])\n    }\n    s.error = function (message) {\n      md._data([s.id, 'error', message])\n    }\n    s.once('close', function () {\n      delete streams[id]\n      streamCount --\n      md._data([s.id, 'close'])\n      if(streamCount === 0)\n        md.emit('zero')\n    })\n    s.writable = opts.writable\n    s.readable = opts.readable\n    streams[s.id = id] = s\n    s.meta = meta\n    return s\n  }\n\n  var outer = serializer(opts.wrapper)(md)\n\n  if(md !== outer)\n    md.on('connection', function (stream) {\n      outer.emit('connection', stream)\n    })\n\n  outer.close = function (cb) {\n    md.once('zero', function () {\n      md._end()\n      if(cb) cb()\n    })\n    return this\n  }\n\n  if(onConnection)\n    outer.on('connection', onConnection)\n\n  outer.on('connection', function (stream) {\n    //if mux-demux recieves a stream but there is nothing to handle it,\n    //then return an error to the other side.\n    //still trying to think of the best error message.\n    if(outer.listeners('connection').length === 1)\n      stream.error('remote end lacks connection listener')\n  })\n\n  var pipe = outer.pipe\n  outer.pipe = function (dest, opts) {\n    pipe.call(outer, dest, opts)\n    md.on('end', destroyAll)\n    md.on('close', destroyAll)\n    md.on('error', destroyAll)\n    return dest\n  }\n\n  outer.createStream = function (meta, opts) {\n    opts = opts || {}\n    if (!opts.writable && !opts.readable)\n      opts.readable = opts.writable = true\n    var s = createStream(createID(), meta, opts)\n    var _opts = {writable: opts.readable, readable: opts.writable}\n    md._data([s.id, 'new', {meta: meta, opts: _opts}])\n    return s\n  }\n  outer.createWriteStream = function (meta) {\n    return outer.createStream(meta, {writable: true, readable: false})\n  }\n  outer.createReadStream = function (meta) {\n    return outer.createStream(meta, {writable: false, readable: true})\n  }\n\n  return outer\n}\n\nmodule.exports = MuxDemux\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/through/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream(), buffer = []\n  stream.buffer = buffer\n  stream.readable = stream.writable = true\n  stream.paused = false\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = function (data) {\n    buffer.push(data)\n    drain()\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/through/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/buffered-opener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar Cache        = require('./cache')\nvar through      = require('through')\n\nmodule.exports = function (schema) {\n  var opener = new EventEmitter()\n  var _opener\n\n  opener.swap = function (newOpener) {\n    if(_opener) throw new Error('already has opener, expects opener.emit(\"close\")')\n    if(!newOpener) throw new Error('cannot swap null')\n    _opener = newOpener\n    _opener.once('close', function () {\n      _opener = null\n    })\n    ready()\n    return opener\n  }\n\n  var toOpen = [], toView = [], _open, _view\n\n  //cache at this level, not on scuttlebutt.open\n\n  opener.open = Cache(schema, function (scuttlebutt, tail, cb) {\n    if('object' !== typeof scuttlebutt)\n      throw new Error('expected Scuttlebutt')\n\n    if(!_opener)\n      return toOpen.push([scuttlebutt, tail, cb])\n\n    _opener.open(scuttlebutt, tail, cb)\n    return scuttlebutt\n  })\n\n  var cache = opener.open.local\n\n  opener.view = function () {\n    var args = [].slice.call(arguments)\n    if(_opener)\n      return _opener.view.apply(null, args)\n    var stream = through()\n    toView.push({args: args, stream: stream})\n    return stream\n  }\n\n  function ready () {\n    while(_opener && toOpen.length) {\n      var args = toOpen.shift()\n      _opener.open.apply(null, args)\n    }\n    while(_opener && toView.length) {\n      var v = toView.shift()\n      _opener.view.apply(null, v.args)\n        .on('error', function (err) {\n          //because stream errors are not propagated...\n          v.stream.emit('error', err)\n        }).pipe(v.stream)\n    }\n\n    //reopen anything that was closed...\n    //for(var key in cache)\n    //  _opener.open(cache[key], true, function () {})\n  }\n\n  return opener\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/buffered-opener.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/cache.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Schema  = require('./schema')\nvar TIMEOUT = 100\n\nmodule.exports = function (schema, open, onCache) {\n  var local = cached.local = {}\n  schema = Schema(schema)\n  function cached (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    //user *must not* pass a Scuttlebutt instance to cached open.\n    if('string' !== typeof name)\n      throw new Error('name must be string')\n\n    //so if this is passed a ready instance...\n    //and there is a cached instance... then pipe them together.\n    //hmm, but the caching should be ontop of the other layer...\n    //will this work?\n    //ah, if a scuttlebutt is passed, and there isn't one in the cache\n    //clone it and put the clone in the cache!\n    //else, pipe it to the cached instace.\n\n    //actually... should combine this into level-scuttlebutt\n    //then only one cache will be necessary.\n\n    //which will work better for reconnections.\n\n    //...so, need lots of tests here.\n\n    //yes, only one cache, the outer most open does not support\n    //opening with a scuttlebutt - but remote, and \n    //level-scuttlebutt do!\n    \n    //then there is only one cache...\n    //so, you always control the point of caching.\n    //no \"russian doll\" caching.\n\n    var cached = local[name]\n    if(cached && 'function' === typeof cached.clone) {\n      var n = cached.clone()\n      n.name = name\n      cb(null, n)\n      return n\n    }\n\n    var clone\n    var scuttlebutt = local[name] = schema(name)\n    scuttlebutt.name = name\n    open(scuttlebutt, tail, function (err, scuttlebutt) {\n      if(err) return cb(err)\n      cb(null, clone)\n    })\n\n    //will callback an error\n    if(!scuttlebutt) return\n\n    scuttlebutt.name = name\n    \n    //only scuttlebutts with clone can be cleanly cached.\n    if('function' === typeof scuttlebutt.clone) {\n      local[name] = scuttlebutt\n      clone = scuttlebutt.clone()\n      clone.name = name\n      if(onCache) onCache('clone', scuttlebutt.name)\n      //okay... have something to dispose the scuttlebutt when there are 0 streams.\n      //hmm, count streams... and emit an event 'unstream' or something?\n      //okay, if all the steams have closed but this one, then it means no one is using this,\n      //so close...\n      //TODO add this to level-scuttlebutt.\n\n      //OH, hang on... maybe DOMAINS is the right thing to use here...\n\n      var timer = null\n      scuttlebutt.on('unstream', function (n) {\n        if(n === 1) {\n          clearTimeout(timer)\n          timer = setTimeout(function () {\n            scuttlebutt.dispose()\n            if(onCache) onCache('uncache', scuttlebutt.name)\n          }, TIMEOUT*1.5)\n            //if an emitter was passed, imet\n        } else if(n > 1)\n          clearTimeout(timer)\n      })\n      scuttlebutt.on('dispose', function () {\n        delete local[name]\n      })\n    }\n    \n    return scuttlebutt\n  }\n\n  return cached\n}\n\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/cache.js"
));

require.define("/node_modules/rumours/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/through/package.json"
));

require.define("/node_modules/rumours/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = []\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = function (data) {\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n    return stream\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/through/index.js"
));

require.define("/node_modules/rumours/node_modules/udid/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/udid/package.json"
));

require.define("/node_modules/rumours/node_modules/udid/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar tabs = require('count-tabs')()\n\nmodule.exports = function (name) {\n\n  //the client side will have different domains,\n  //and thus different localStorages per app,\n  //so we don't need to use the name...\n  //however, still use the same api as on the server.\n\n  if(!name)\n    throw new Error('provide app name')\n\n  return tabs.id\n  \n}\n  \n\n//@ sourceURL=/node_modules/rumours/node_modules/udid/browser.js"
));

require.define("/node_modules/rumours/node_modules/udid/node_modules/count-tabs/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/udid/node_modules/count-tabs/package.json"
));

require.define("/node_modules/rumours/node_modules/udid/node_modules/count-tabs/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar hash = require('shasum')\n\nvar id\nvar KEY = 'tabsQuery'\nvar tabs = {}\nvar pattern = /^tabs:(.+)$/\nvar emitter, oldUp\n\n//NOTE. this module uses a global singleton,\n//so the first thing to require it must set the interval\n//else, you will be stuck with the default.\n\n//disabling the interval option for now.\n//is unstable under 500 ms.\nmodule.exports = function (/*interval, */listener) {\n  //if('function' === typeof interval)\n  //  listener = interval, interval = 1000\n  var interval = 500\n\n  function attach() {\n    if(listener) {\n      emitter.on('change', listener)\n      listener.call(emitter, emitter.up, 0)\n    }\n  }\n\n  if(emitter) {\n    attach()\n    return emitter\n  }\n\n  emitter = new EventEmitter()\n\n  emitter.tabs = tabs\n\n  var start = Date.now()\n  for( var key in localStorage) {\n    var m\n    if(m = pattern.exec(key)) {\n      var _id = m[1]\n      if(!id && Number(localStorage[key]) < start - interval*2) {\n        emitter.id = id = _id\n        localStorage['tabs:'+id] = start //claim this key\n      }\n      tabs[_id] = Number(localStorage[key])\n    }\n  }\n\n  if(!id) {\n    emitter.id = id = hash(Date.now())\n    tabs[id] = localStorage['tabs:'+id] = start//claim this key\n  }\n\n  function count () {\n    var now = Date.now()\n    \n    for(var _id in tabs) {\n      if(Number(tabs[_id]) < now - interval*2) {\n        delete tabs[_id]\n        //don't delete old ids, so they can be reused,\n        //making for smaller vector-clocks.\n        //delete localStorage['tabs:'+_id]\n        emitter.emit('close', _id)\n        change = true\n      }\n    }\n    var up = Object.keys(tabs).sort()\n    if(!oldUp || up.join('|') != oldUp.join('|')) {\n      var l = oldUp ? oldUp.length : 0\n      emitter.up = up.length\n      oldUp = up\n      emitter.emit('change', tabs, l)\n    }\n  }\n\n  count()\n\n  window.addEventListener('storage', function (se) {\n    if(m = pattern.exec(se.key)) {\n      var _id = m[1]\n      if(se.newValue)\n        tabs[_id] = Number(se.newValue)\n      else\n        delete tabs[_id] \n      count()\n    }\n  })  \n\n  setInterval(function () {\n    tabs[id] = localStorage['tabs:'+id] = Date.now()\n    count()\n  }, interval)\n\n  attach()\n\n  return emitter\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/udid/node_modules/count-tabs/index.js"
));

require.define("/node_modules/rumours/node_modules/shasum/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/shasum/package.json"
));

require.define("/node_modules/rumours/node_modules/shasum/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar createHash = require('crypto').createHash \nvar Buffer = require('buffer').Buffer\nmodule.exports = function hash (str, alg, format) {\n  str = 'string' === typeof str ? str\n    : Buffer.isBuffer(str) ? str\n    : JSON.stringify(str)\n  return createHash(alg || 'sha1').update(str).digest(format || 'hex')\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/shasum/index.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("buffer",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"buffer-browserify\")\n//@ sourceURL=buffer"
));

require.define("/node_modules/buffer-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"index.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/package.json"
));

require.define("/node_modules/buffer-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n//@ sourceURL=/node_modules/buffer-browserify/index.js"
));

require.define("assert",Function(['require','module','exports','__dirname','__filename','process','global'],"// UTILITY\nvar util = require('util');\nvar Buffer = require(\"buffer\").Buffer;\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n//@ sourceURL=assert"
));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/b64.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/package.json"
));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js",Function(['require','module','exports','__dirname','__filename','process','global'],"(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js"
));

require.define("/node_modules/buffer-browserify/buffer_ieee754.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n//@ sourceURL=/node_modules/buffer-browserify/buffer_ieee754.js"
));

require.define("/node_modules/rumours/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function create (con) {\n  return function () {\n    return new con()\n  }\n}\n\n//all the scuttlebutt subclasses written so far.\n\nmodule.exports = {\n  'model': create(require('scuttlebutt/model')),\n  'events': create(require('scuttlebutt/events')),\n  'r-edit': create(require('r-edit')),\n  'r-array': create(require('r-array')),\n  'crdt': create(require('crdt')),\n  'append-only': create(require('append-only')),\n  'expiry-model': create(require('expiry-model'))\n  //hmm, what about scuttlebucket?\n}\n\n\n//@ sourceURL=/node_modules/rumours/schema.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/model.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require('./index')\nvar inherits = require('util').inherits\nvar each = require('iterate').each\nvar u = require('./util')\n\nmodule.exports = Model\n\ninherits(Model, Scuttlebutt)\n\nfunction Model (opts) {\n  if(!(this instanceof Model)) return new Model(opts)\n  Scuttlebutt.call(this, opts)\n  this.store = {}\n}\n\nvar m = Model.prototype\n\nm.set = function (k, v) {\n  this.localUpdate([k, v])\n  return this\n}\n\nm.get = function (k) {\n  if(this.store[k])\n    return this.store[k][0][1]\n}\n\n//return this history since sources.\n//sources is a hash of { ID: TIMESTAMP }\n\nm.applyUpdate = function (update) {\n  var key = update[0][0]\n  //ignore if we already have a more recent value\n  if('undefined' !== typeof this.store[key]\n    && this.store[key][1] > update[1])\n    return this.emit('_remove', update)\n\n  if(this.store[key]) this.emit('_remove', this.store[key])\n\n  this.store[key] = update\n  this.emit.apply(this, ['update'].concat(update))\n  this.emit('change', key, update[0][1])\n  this.emit('change:'+key, update[0][1])\n\n  return true\n}\n\nm.history = function (sources) {\n  var self = this\n  var h = []\n  each(this.store, function (e) {\n    if(u.filter(e, sources))\n      h.push(e)\n  })\n  return h\n}\n\nm.toJSON = function () {\n  var o = {}\n  for (var k in this.store)\n    o[k] = this.get(k)\n  return o\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/model.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar i = require('iterate')\nvar duplex = require('duplex')\nvar inherits = require('util').inherits\nvar serializer = require('stream-serializer')\nvar u = require('./util')\nvar timestamp = require('monotonic-timestamp')\n\nexports = \nmodule.exports = Scuttlebutt\n\nexports.createID = u.createID\nexports.updateIsRecent = u.filter\nexports.filter = u.filter\nexports.timestamp = timestamp\n\nfunction dutyOfSubclass() {\n  throw new Error('method must be implemented by subclass')\n}\n\nfunction validate (data) {\n  var ts = data[1], source = data[2]\n\n  if(  !Array.isArray(data) \n    || 'string'    !== typeof source\n    || 'number'    !== typeof ts\n  ) return false\n\n  return true\n}\n\nvar emit = EventEmitter.prototype.emit\n\ninherits (Scuttlebutt, EventEmitter)\n\nfunction Scuttlebutt (opts) {\n\n  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)\n  var id = 'string' === typeof opts ? opts : opts && opts.id\n  this.sources = {}\n  this.setMaxListeners(Number.MAX_VALUE)\n  //count how many other instances we are replicating to.\n  this._streams = 0\n  if(opts && opts.sign && opts.verify) {\n    this.id      = opts.id || opts.createId()\n    this._sign   = opts.sign\n    this._verify = opts.verify\n  } else {\n    this.id = id || u.createId()\n  }\n}\n\nvar sb = Scuttlebutt.prototype\n\nvar emit = EventEmitter.prototype.emit\n\nsb.applyUpdate = dutyOfSubclass\nsb.history      = dutyOfSubclass\n\nsb.localUpdate = function (trx) {\n  this._update([trx, timestamp(), this.id])\n  return this\n}\n\nsb._update = function (update) {\n  var ts = update[1]\n  var source = update[2]\n  //if this message is old for it's source,\n  //ignore it. it's out of order.\n  //each node must emit it's changes in order!\n  \n  var latest = this.sources[source]\n  if(latest && latest >= ts)\n    return emit.call(this, 'old_data', update), false\n\n  this.sources[source] = ts\n\n  var self = this\n  function didVerification (err, verified) {\n\n    // I'm not sure how what should happen if a async verification\n    // errors. if it's an key not found - that is a verification fail,\n    // not a error. if it's genunie error, really you should queue and \n    // try again? or replay the message later\n    // -- this should be done my the security plugin though, not scuttlebutt.\n\n    if(err)\n      return emit.call(self, 'error', err)\n\n    if(!verified)\n      return emit.call(self, 'unverified_data', update)\n\n    // check if this message is older than\n    // the value we already have.\n    // do nothing if so\n    // emit an 'old_data' event because i'll want to track how many\n    // unnecessary messages are sent.\n\n    if(self.applyUpdate(update))\n      emit.call(self, '_update', update) //write to stream.\n\n  }\n\n  if(source !== this.id) {\n    if(this._verify)\n      this._verify(update, didVerification)\n    else\n      didVerification(null, true)\n  } else {\n    if(this._sign) {\n      //could make this async easily enough.\n      update[3] = this._sign(update)\n    }\n    didVerification(null, true)\n  }\n\n  return true\n}\n\nsb.createStream = function (opts) {\n  var self = this\n  //the sources for the remote end.\n  var sources = {}, other\n  var syncSent = false, syncRecv = false\n\n  this._streams ++\n\n  opts = opts || {}\n  var d = duplex()\n  d.name = opts.name\n  var outer = serializer(opts && opts.wrapper)(d)\n  outer.inner = d\n\n  d.writable = opts.writable !== false\n  d.readable = opts.readable !== false\n\n  syncRecv   = !d.writable\n  syncSent   = !d.readable\n\n  var tail = opts.tail !== false //default to tail=true\n\n  function start (data) {\n    //when the digest is recieved from the other end,\n    //send the history.\n    //merge with the current list of sources.\n    sources = data.clock\n    i.each(self.history(sources), function (data) {d._data(data)})\n    \n    outer.emit('header', data)\n    d._data('SYNC')\n    //when we have sent all history\n    outer.emit('syncSent')\n    syncSent = true\n    //when we have recieved all histoyr\n    //emit 'synced' when this stream has synced.\n    if(syncRecv) outer.emit('sync'), outer.emit('synced')\n    if(!tail) d._end()\n  }\n\n  d\n    .on('_data', function (data) {\n      //if it's an array, it's an update.\n      if(Array.isArray(data)) {\n        if(validate(data))\n          return self._update(data)\n      }\n      //if it's an object, it's a scuttlebut digest.\n      else if('object' === typeof data && data)\n        start(data)\n      else if('string' === typeof data && data == 'SYNC') {\n        syncRecv = true\n        outer.emit('syncRecieved')\n        if(syncSent) outer.emit('sync'), outer.emit('synced')\n      }\n    }).on('_end', function () {\n      d._end()\n    })\n    .on('close', function () {\n      self.removeListener('_update', onUpdate)\n      //emit the number of streams that are remaining...\n      //this will be used for memory management...\n      self._streams --\n      emit.call(self, 'unstream', self._streams)\n    })\n\n  if(opts && opts.tail === false) {\n    outer.on('sync', function () {\n      process.nextTick(function () {\n        d._end()\n      })\n    })\n  }\n  function onUpdate (update) { //key, value, source, ts\n    if(!u.filter(update, sources))\n      return\n\n    d._data(update)\n\n    //really, this should happen before emitting.\n    var ts = update[1]\n    var source = update[2]\n    sources[source] = ts\n  }\n\n  var outgoing = { id : self.id, clock : self.sources }\n\n  if (opts && opts.meta) outgoing.meta = opts.meta\n\n  if(d.readable) {\n    d._data(outgoing)\n    if(!d.writable)\n      start({clock:{}})\n    if(tail)\n      self.on('_update', onUpdate)\n  }\n\n  self.once('dispose', function () {\n    d.end()\n  })\n\n  return outer\n}\n\nsb.createWriteStream = function (opts) {\n  opts = opts || {}\n  opts.writable = true; opts.readable = false\n  return this.createStream(opts)\n}\n\nsb.createReadStream = function (opts) {\n  opts = opts || {}\n  opts.writable = false; opts.readable = true\n  return this.createStream(opts)\n}\n\nsb.dispose = function () {\n  emit.call(this, 'dispose')\n}\n\nsb.setId = function (id) {\n  this.id = id\n  return this\n}\n\n//create another instance of this scuttlebutt,\n//that is in sync and attached to this instance.\nsb.clone = function () {\n  var A = this\n  var B = new (A.constructor)\n  B.setId(A.id) //same id. think this will work...\n\n  var a = A.createStream({wrapper: 'raw'})\n  var b = B.createStream({wrapper: 'raw'})\n\n  //all updates must be sync, so make sure pause never happens.\n  a.pause = b.pause = function noop(){}\n\n  a.pipe(b).pipe(a)\n  //resume both streams, so that the new instance is brought up to date immediately.\n  a.resume()\n  b.resume()\n\n  return B\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//\n// adds all the fields from obj2 onto obj1\n//\n\nvar each = exports.each = function (obj,iterator){\n var keys = Object.keys(obj)\n keys.forEach(function (key){\n  iterator(obj[key],key,obj) \n })\n}\n\nvar RX = /sadf/.constructor\nfunction rx (iterator ){\n  return iterator instanceof RX ? function (str) { \n      var m = iterator.exec(str)\n      return m && (m[1] ? m[1] : m[0]) \n    } : iterator\n}\n\nvar times = exports.times = function () {\n  var args = [].slice.call(arguments)\n    , iterator = rx(args.pop())\n    , m = args.pop()\n    , i = args.shift()\n    , j = args.shift()\n    , diff, dir\n    , a = []\n    \n    i = 'number' === typeof i ? i : 1\n    diff = j ? j - i : 1\n    dir = i < m\n    if(m == i)\n      throw new Error('steps cannot be the same: '+m+', '+i)\n  for (; dir ? i <= m : m <= i; i += diff)\n    a.push(iterator(i))\n  return a\n}\n\nvar map = exports.map = function (obj, iterator){\n  iterator = rx(iterator)\n  if(Array.isArray(obj))\n    return obj.map(iterator)\n  if('number' === typeof obj)\n    return times.apply(null, [].slice.call(arguments))  \n  //return if null ?  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    r[key] = iterator(obj[key],key,obj) \n  })\n  return r\n}\n\nvar findReturn = exports.findReturn = function (obj, iterator) {\n  iterator = rx(iterator)\n  if(obj == null)\n    return\n  var keys = Object.keys(obj)\n    , l = keys.length\n  for (var i = 0; i < l; i ++) {\n    var key = keys[i]\n      , value = obj[key]\n    var r = iterator(value, key)\n    if(r) return r\n  }\n}\n\nvar find = exports.find = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return v\n  })\n}\n\nvar findKey = exports.findKey = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return k\n  })\n}\n\nvar filter = exports.filter = function (obj, iterator){\n  iterator = rx (iterator)\n\n  if(Array.isArray(obj))\n    return obj.filter(iterator)\n  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    var v\n    if(iterator(v = obj[key],key,obj))\n      r[key] = v\n  })\n  return r \n}\n\nvar mapKeys = exports.mapKeys = function (ary, iterator){\n  var r = {}\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r[v] = iterator(v,k)\n  })\n  return r\n}\n\n\nvar mapToArray = exports.mapToArray = function (ary, iterator){\n  var r = []\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r.push(iterator(v,k))\n  })\n  return r\n}\n\nvar path = exports.path = function (object, path) {\n\n  for (var i in path) {\n    if(object == null) return undefined\n    var key = path[i]\n    object = object[key]\n  }\n  return object\n}\n\n/*\nNOTE: naive implementation. \n`match` must not contain circular references.\n*/\n\nvar setPath = exports.setPath = function (object, path, value) {\n\n  for (var i in path) {\n    var key = path[i]\n    if(object[key] == null) object[key] = ( \n      i + 1 == path.length ? value : {}\n    )\n    object = object[key]\n  }\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/util.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.createId = \nfunction () {\n  return [1,1,1].map(function () {\n    return Math.random().toString(16).substring(2).toUpperCase()\n  }).join('')\n}\n\nexports.filter = function (update, sources) {\n  var ts = update[1]\n  var source = update[2]\n  return (!sources || !sources[source] || sources[source] < ts)\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/util.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _last = 0\nvar _count = 1\nvar LAST\n\nmodule.exports = \nfunction () {\n  var t = Date.now()\n  var _t = t\n  if(_last == t) {\n    _t += ((_count++)/1000) \n  } \n  else _count = 1 \n\n  _last = t\n\n  if(_t === LAST)\n    throw new Error('LAST:' + LAST + ',' + _t)\n  LAST = _t\n  return _t\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/events.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require('./')\nvar inherits = require('util').inherits\nvar each = require('iterate').each\nvar u = require('./util')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = ReliableEventEmitter\n\ninherits(ReliableEventEmitter, Scuttlebutt)\n\nfunction ReliableEventEmitter (opts) {\n  if(!(this instanceof ReliableEventEmitter)) return new ReliableEventEmitter(opts)\n  Scuttlebutt.call(this, opts)\n}\n\nvar emit = EventEmitter.prototype.emit\nvar emitter = ReliableEventEmitter.prototype\n\nemitter.emit = function (event) {\n  var args = [].slice.call(arguments)\n  if(event == 'newListener')\n    return emit.apply(this, args)\n  return this.localUpdate(args)\n}\n\nemitter.applyUpdate = function (update) {\n  var key = update[0][0]\n  this.events = this.events || {}\n  this.events[key] = this.events[key] || []\n  this.events[key].push(update)\n  //emit the event.\n  emit.apply(this, update[0])\n  return true\n}\n\n\nemitter.history = function (filter) {\n  var self = this\n  var h = []\n  this.events = this.events || {}\n  each(this.events, function (es) {\n    each(es, function (e) {\n      if(u.filter(e, filter))\n        h.push(e)\n    })\n  })\n  return h.sort(function (a, b) {\n    //sort my timestamps.\n    // so will be A1 B1 A2 B2,\n    // not A1 A2 B1 B2\n    return a[1] - b[1]\n  })\n}\n\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/events.js"
));

require.define("/node_modules/r-edit/node_modules/r-edit/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-edit/package.json"
));

require.define("/node_modules/r-edit/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var diff     = require('adiff').diff\nvar RArray   = require('r-array')\nvar inherits = require('util').inherits\n\nfunction patch (a, changes) {\n  changes.forEach(function (patch) {\n    a.splice.apply(a, patch)\n  })\n  return a\n}\n\nfunction split(str) {\n  return str.split('\\n').map(function (l, i, a) {\n    if(i != a.length - 1)\n      return l + '\\n'\n    return l\n  })\n}\n\nmodule.exports = REdit\n\ninherits(REdit, RArray)\n\nfunction REdit() {\n  if(!(this instanceof REdit)) return new REdit()\n  RArray.call(this)\n}\n\nvar R = REdit.prototype\n\nR.text  = function text (text) {\n  if(!arguments.length)\n    return this.toJSON().join('')\n  \n  var old = this.toJSON()\n  text = split(text)\n  //got to adjust the user's selection on the text area...\n  var p = diff(old, text)\n  patch(this, p)\n}\n\nR.unwrap = function () {\n\n}\n\nR.widget = function () {\n  var ta = document.createElement('textarea')\n  ta.setAttribute('cols', 80)\n  ta.setAttirbute('rows', 24)\n  this.wrap(ta)\n  return ta\n}\n\nR.wrap = function (ta) {\n  if(!ta) throw new Error('wrap(ta) expects TextArea, or Input')\n\n  var cursor = 0, start\n  var self = this\n\n  if(this.wrapped)\n    throw new Error('rEdit is already wrapping a textarea. unwrap it first!')\n\n  if(ta._rEditWrapper)\n    ta._rEditWrapper.unwrap()\n\n  ta._rEditWrapper = this\n  this.wrapped = ta\n\n  ta.value = this.text()\n\n  function onPreupdate (ch) {\n    //force update when recieve message.\n    cursor = 0\n    start = ta.selectionStart\n    end   = ta.selectionEnd\n    //what atom contains the cursor?\n    var startKey, sum = 0\n    for (var i in self.keys) {\n      var key = self.keys[i]\n      if((sum = self.store[key].length + sum) >= start) {\n        startKey = key; break\n      }\n    }\n    //how much will be inserted into the document?\n    for(var key in ch) {\n      if(key < startKey)\n        cursor += \n          (ch[key] ? ch[key].length : 0)\n        - (self.store[key] ? self.store[key].length : 0)\n    }\n    //THIS IS ACTUALLY WRONG. CAN'T insert into a selection!\n    start = start + cursor\n    end   = end   + cursor\n  }\n  this.on('preupdate', onPreupdate)\n  function on_update (update) {\n    if(update[2] !== self.id) {\n      ta.value = self.toJSON().join('')\n      ta.selectionStart = ta.selectionEnd = start\n    }\n  }\n  this.on('_update'  , on_update)\n  var pending = false\n  function onInput () {\n    //if(pending) return\n    //pending = true\n    //setTimeout(function () {\n    //pending = false\n    self.text(ta.value)\n    //}, 300)\n  }\n  function onKeydown () {\n    start = ta.selectionStart\n    end   = ta.selectionEnd\n  }\n  function onFocus () {\n    ta.selectionStart = ta.selectionEnd = start\n  }\n  ta.addEventListener('input'  , onInput)\n  ta.addEventListener('keydown', onKeydown)\n  ta.addEventListener('focus'  , onFocus )\n\n  this.unwrap = function () {\n    ta.removeEventListener('input'  , onInput)\n    ta.removeEventListener('keydown', onKeydown)\n    ta.removeEventListener('focus'  , onFocus)\n    this.removeListener('preupdate' , onPreupdate)\n    this.removeListener('_update'   , on_update)\n    this.unwrap = function () {}\n  }\n\n  return this\n}\n\n//@ sourceURL=/node_modules/r-edit/index.js"
));

require.define("/node_modules/r-edit/node_modules/adiff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/r-edit/node_modules/adiff/package.json"
));

require.define("/node_modules/r-edit/node_modules/adiff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function head (a) {\n  return a[0]\n}\n\nfunction last (a) {\n  return a[a.length - 1]\n}\n\nfunction tail(a) {\n  return a.slice(1)\n}\n\nfunction retreat (e) {\n  return e.pop()\n}\n\nfunction hasLength (e) {\n  return e.length\n}\n\nfunction any(ary, test) {\n  for(var i in ary)\n    if(test(ary[i]))\n      return true\n  return false\n}\n\nvar _rules // set at the bottom  \n\n// note, naive implementation. will break on circular objects.\n\nfunction _equal(a, b) {\n  if(a && !b) return false\n  if(Array.isArray(a))\n    if(a.length != b.length) return false\n  if(a && 'object' == typeof a) {\n    for(var i in a)\n      if(!_equal(a[i], b[i])) return false\n    return true\n  }\n  return a == b\n}\n\nfunction getArgs(args) {\n  return args.length == 1 ? args[0] : [].slice.call(args)\n}\n\n// return the index of the element not like the others, or -1\nfunction oddElement(ary, cmp) {\n  var c\n  function guess(a) {\n    var odd = -1\n    c = 0\n    for (var i = a; i < ary.length; i ++) {\n      if(!cmp(ary[a], ary[i])) {\n        odd = i, c++\n      }\n    }\n    return c > 1 ? -1 : odd\n  }\n  //assume that it is the first element.\n  var g = guess(0)\n  if(-1 != g) return g\n  //0 was the odd one, then all the other elements are equal\n  //else there more than one different element\n  guess(1)\n  return c == 0 ? 0 : -1\n}\nvar exports = module.exports = function (deps, exports) {\n  var equal = (deps && deps.equal) || _equal\n  exports = exports || {} \n  exports.lcs = \n  function lcs() {\n    var cache = {}\n    var args = getArgs(arguments)\n    var a = args[0], b = args[1]\n\n    function key (a,b){\n      return a.length + ':' + b.length\n    }\n\n    //find length that matches at the head\n\n    if(args.length > 2) {\n      //if called with multiple sequences\n      //recurse, since lcs(a, b, c, d) == lcs(lcs(a,b), lcs(c,d))\n      args.push(lcs(args.shift(), args.shift()))\n      return lcs(args)\n    }\n    \n    //this would be improved by truncating input first\n    //and not returning an lcs as an intermediate step.\n    //untill that is a performance problem.\n\n    var start = 0, end = 0\n    for(var i = 0; i < a.length && i < b.length \n      && equal(a[i], b[i])\n      ; i ++\n    )\n      start = i + 1\n\n    if(a.length === start)\n      return a.slice()\n\n    for(var i = 0;  i < a.length - start && i < b.length - start\n      && equal(a[a.length - 1 - i], b[b.length - 1 - i])\n      ; i ++\n    )\n      end = i\n\n    function recurse (a, b) {\n      if(!a.length || !b.length) return []\n      //avoid exponential time by caching the results\n      if(cache[key(a, b)]) return cache[key(a, b)]\n\n      if(equal(a[0], b[0]))\n        return [head(a)].concat(recurse(tail(a), tail(b)))\n      else { \n        var _a = recurse(tail(a), b)\n        var _b = recurse(a, tail(b))\n        return cache[key(a,b)] = _a.length > _b.length ? _a : _b  \n      }\n    }\n    \n    var middleA = a.slice(start, a.length - end)\n    var middleB = b.slice(start, b.length - end)\n\n    return (\n      a.slice(0, start).concat(\n        recurse(middleA, middleB)\n      ).concat(a.slice(a.length - end))\n    )\n  }\n\n  // given n sequences, calc the lcs, and then chunk strings into stable and unstable sections.\n  // unstable chunks are passed to build\n  exports.chunk =\n  function (q, build) {\n    var q = q.map(function (e) { return e.slice() })\n    var lcs = exports.lcs.apply(null, q)\n    var all = [lcs].concat(q)\n\n    function matchLcs (e) {\n      if(e.length && !lcs.length || !e.length && lcs.length)\n        return false //incase the last item is null \n      return equal(last(e), last(lcs)) || ((e.length + lcs.length) === 0)\n    }\n\n    while(any(q, hasLength)) {\n      //if each element is at the lcs then this chunk is stable.\n      while(q.every(matchLcs) && q.every(hasLength)) \n        all.forEach(retreat) \n      //collect the changes in each array upto the next match with the lcs\n      var c = false\n      var unstable = q.map(function (e) {\n        var change = []\n        while(!matchLcs(e)) {\n          change.unshift(retreat(e))\n          c = true\n        }\n        return change\n      })\n      if(c) build(q[0].length, unstable) \n    }\n  }\n\n  exports.diff =\n  function (a, b) {\n    var changes = []\n    exports.chunk([a, b], function (index, unstable) {\n      var del = unstable.shift().length\n      var insert = unstable.shift()\n      changes.push([index, del].concat(insert))\n    })\n    return changes\n  }\n\n  exports.patch = function (a, changes, mutate) {\n    if(mutate !== true) a = a.slice(a)//copy a\n    changes.forEach(function (change) {\n      [].splice.apply(a, change)\n    })\n    return a\n  }\n\n  // http://en.wikipedia.org/wiki/Concestor\n  // me, concestor, you...\n  exports.merge = function () {\n    var args = getArgs(arguments)\n    var patch = exports.diff3(args)\n    return exports.patch(args[0], patch)\n  }\n\n  exports.diff3 = function () {\n    var args = getArgs(arguments)\n    var r = []\n    exports.chunk(args, function (index, unstable) {\n      var mine = unstable[0]\n      var insert = resolve(unstable)\n      if(equal(mine, insert)) return \n      r.push([index, mine.length].concat(insert)) \n    })\n    return r\n  }\n  exports.oddOneOut =\n    function oddOneOut (changes) {\n      changes = changes.slice()\n      //put the concestor first\n      changes.unshift(changes.splice(1,1)[0])\n      var i = oddElement(changes, equal)\n      if(i == 0) // concestor was different, 'false conflict'\n        return changes[1]\n      if (~i)\n        return changes[i] \n    }\n  exports.insertMergeOverDelete = \n    //i've implemented this as a seperate rule,\n    //because I had second thoughts about this.\n    function insertMergeOverDelete (changes) {\n      changes = changes.slice()\n      changes.splice(1,1)// remove concestor\n      \n      //if there is only one non empty change thats okay.\n      //else full confilct\n      for (var i = 0, nonempty; i < changes.length; i++)\n        if(changes[i].length) \n          if(!nonempty) nonempty = changes[i]\n          else return // full conflict\n      return nonempty\n    }\n\n  var rules = (deps && deps.rules) || [exports.oddOneOut, exports.insertMergeOverDelete]\n\n  function resolve (changes) {\n    var l = rules.length\n    for (var i in rules) { // first\n      \n      var c = rules[i] && rules[i](changes)\n      if(c) return c\n    }\n    changes.splice(1,1) // remove concestor\n    //returning the conflicts as an object is a really bad idea,\n    // because == will not detect they are the same. and conflicts build.\n    // better to use\n    // '<<<<<<<<<<<<<'\n    // of course, i wrote this before i started on snob, so i didn't know that then.\n    /*var conflict = ['>>>>>>>>>>>>>>>>']\n    while(changes.length)\n      conflict = conflict.concat(changes.shift()).concat('============')\n    conflict.pop()\n    conflict.push          ('<<<<<<<<<<<<<<<')\n    changes.unshift       ('>>>>>>>>>>>>>>>')\n    return conflict*/\n    //nah, better is just to use an equal can handle objects\n    return {'?': changes}\n  }\n  return exports\n}\nexports(null, exports)\n\n//@ sourceURL=/node_modules/r-edit/node_modules/adiff/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar between     = require('between')\nvar Scuttlebutt = require('scuttlebutt')\nvar inherits    = require('util').inherits\nvar filter      = require('scuttlebutt/util').filter\n\ninherits(RArray, Scuttlebutt)\n\nmodule.exports = RArray\n\nfunction fuzz () {\n  return Math.random().toString().substring(2, 5)\n}\n\nvar DOEMIT = true, CHANGE = {}\n\nfunction order (a, b) {\n  //timestamp, then source\n  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])\n}\n\nfunction RArray () {\n  Scuttlebutt.call(this)\n  this.keys = []\n  this.store = {}\n  this._hist = {}\n  this.length = 0\n  if(arguments.length) {\n    var self = this\n    ;[].forEach.call(arguments, function (e) {\n      self.push(e)\n    })\n  }\n}\n\nvar A = RArray.prototype\n\nA.last = function () {\n  return this.keys[this.keys.length - 1]\n}\n\nA.first = function () {\n  return this.keys[0]\n}\n\nA.insert = function (before, val, after) {  \n  var key = between(before || between.lo, after || between.hi) + fuzz()\n  this.set(key, val)\n  return key\n}\n\nA.push = function (val) {\n  var key = this.insert(this.last(), val)\n}\n\nA.unshift = function (val) {\n  var key = this.insert(null, val, this.first())\n}\n\nA.indexOf = function (val) {\n  for(var i in this.keys) {\n    var key = this.keys[i]\n    if(v === this.get(key)) return i\n  }\n  return null\n}\n\nA.indexOfKey = function (key) {\n  return this.keys.indexOf(key)\n}\n\nA.toJSON = function () {\n  var store = this.store\n  var self = this\n  return this.keys.map(function (key) {\n    return self.get(key)\n  })\n}\n\nA.set = function (key, val) {\n  if('string' == typeof key) {\n    if(val === null) return this.unset(key)\n    if(null == this.store[key]) this.length ++\n    this.store[key] = val\n    if(!~this.keys.indexOf(key)) {\n      this.keys.push(key)\n      this.keys.sort()\n    }\n    CHANGE[key] = val\n    DOEMIT && this._emit()\n  }\n}\n\nA.get = function (key) {\n  return this.store[key]\n}\n\nA.unset = function (key) {\n  if('string' == typeof key) {\n    if(null != this.store[key]) this.length --\n    delete this.store[key]\n    var i = this.keys.indexOf(key)\n    if(!~i) return\n    this.keys.splice(i, 1)    \n\n    CHANGE[key] = null\n    DOEMIT && this._emit()\n  }\n}\n\nA.pop = function () {\n  var l = this.last()\n  var val = this.store[l]\n  this.unset(l)\n  return val\n}\n\nA.shift = function () {\n  var f = this.first()\n  var val = this.store[f]\n  this.unset(f)\n  return val\n}\n\nA._emit = function () {\n  if(!DOEMIT) return\n  this.localUpdate(CHANGE)\n  CHANGE = {}\n}\n\nA.splice = function (i, d /*,...args*/) {\n  var args = [].slice.call(arguments, 2)\n  var j = 0, l = args.length\n\n  DOEMIT = false\n\n  if(d + i > this.keys.length)\n    d = this.keys.length - i\n  \n  while(j < d) {\n    if(j < l)\n      this.set(this.keys[i+j], args[j]), j++\n    else\n      this.unset(this.keys[i+j]), d--\n  }\n\n  while(j < l)\n    this.insert(this.keys[i+j-1], args[j], this.keys[i+j]), j++\n\n  DOEMIT = true\n  this._emit()\n}\n\nA.applyUpdate = function (update) {\n  DOEMIT = false\n  var change = update[0], old\n  var apply = {}, ch = {}\n  var old = {}\n  for(var key in change) {\n    if(!this._hist[key] || order(update, this._hist[key]) > 0)\n      apply[key] = change[key]\n  }\n  //allow the user to see what the change is going to be.\n  this.emit('preupdate', apply) \n\n  //apply the change...\n  for(var key in apply) {\n    var o = this._hist[key]\n    o && (old[o[1]+':'+o[2]] = o) //ts:source\n    this._hist[key] = update\n    this.set(key, apply[key])\n  }\n\n  //check if old elements need to be removed.\n  //may also want to keep old updates hanging around \n  //so the user can see recent history...\n  for(var id in old) {\n    var o = old[id][0], rm = true\n    for(var key in o) {\n      if(this._hist[key] === old[id]) rm = false\n    }\n    if(rm)\n      this.emit('_remove', old[id])\n  }\n    \n  DOEMIT = true\n  CHANGE = {}\n  this.emit('update', apply)\n  return true\n}\n\n\nA.history = function (sources) {\n  var h = []\n  for (var key in this._hist) {\n    var update = this._hist[key]\n      if(!~h.indexOf(update) && filter(update, sources))\n        h.push(update)\n  }\n  return h.sort(order)\n}\n\nA.forEach = function (fun) {\n  return this.toJSON().forEach(fun)\n}\n\nA.filter = function (fun) {\n  return this.toJSON().filter(fun)\n}\n\nA.map = function (fun) {\n  return this.toJSON().map(fun)\n}\n\nA.reduce = function (fun, initial) {\n  return this.toJSON().reduce(fun, initial)\n}\n\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/between/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/between/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/between/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction inject (chars) {\n\n  chars = chars ||\n  '!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'\n\n  chars = chars.split('').sort().join('')\n\n  var exports = between\n\n  exports.between   = between\n\n  exports.randstr   = randstr\n  exports.between   = between\n  exports.strord    = strord\n\n  exports.lo        = chars[0]\n  exports.hi        = chars[chars.length - 1]\n\n  exports.inject    = inject\n\n  function randstr(l) {\n    var str = ''\n    while(l--) \n      str += chars[\n        Math.floor(\n          Math.random() * chars.length \n        )\n      ]\n    return str\n  }\n\n  /*\n    SOME EXAMPLE STRINGS, IN ORDER\n   \n    0\n    00001\n    0001\n    001\n    001001\n    00101\n    0011\n    0011001\n    001100101\n    00110011\n    001101\n    00111\n    01  \n\n    if you never make a string that ends in the lowest char,\n    then it is always possible to make a string between two strings.\n    this is like how decimals never end in 0. \n\n    example:\n\n    between('A', 'AB') \n\n    ... 'AA' will sort between 'A' and 'AB' but then it is impossible\n    to make a string inbetween 'A' and 'AA'.\n    instead, return 'AAB', then there will be space.\n\n  */\n\n  function between (a, b) {\n\n    var s = '', i = 0\n\n    while (true) {\n\n      var _a = chars.indexOf(a[i])\n      var _b = chars.indexOf(b[i])\n     \n      if(_a == -1) _a = 0\n      if(_b == -1) _b = chars.length - 1\n\n      i++\n\n      var c = chars[\n          _a + 1 < _b \n        ? Math.round((_a+_b)/2)\n        : _a\n      ]\n\n      s += c\n\n      if(a < s && s < b && c != exports.lo)\n        return s;\n    }\n  }\n\n  function strord (a, b) {\n    return (\n      a == b ?  0\n    : a <  b ? -1\n    :           1\n    )\n  }\n\n  between.strord\n\n  return between\n}\n\n\nmodule.exports = inject(null)\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/between/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar i = require('iterate')\nvar duplex = require('duplex')\nvar inherits = require('util').inherits\nvar serializer = require('stream-serializer')\nvar u = require('./util')\nvar timestamp = require('monotonic-timestamp')\n\nexports = \nmodule.exports = Scuttlebutt\n\nexports.createID = u.createID\nexports.updateIsRecent = u.filter\nexports.filter = u.filter\nexports.timestamp = timestamp\n\nfunction dutyOfSubclass() {\n  throw new Error('method must be implemented by subclass')\n}\n\nfunction validate (data) {\n  var ts = data[1], source = data[2]\n\n  if(  !Array.isArray(data) \n    || 'string'    !== typeof source\n    || 'number'    !== typeof ts\n  ) return false\n\n  return true\n}\n\nvar emit = EventEmitter.prototype.emit\n\ninherits (Scuttlebutt, EventEmitter)\n\nfunction Scuttlebutt (opts) {\n\n  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)\n  var id = 'string' === typeof opts ? opts : opts && opts.id\n  this.sources = {}\n  this.setMaxListeners(Number.MAX_VALUE)\n  //count how many other instances we are replicating to.\n  this._streams = 0\n  if(opts && opts.sign && opts.verify) {\n    this.id      = opts.id || opts.createId()\n    this._sign   = opts.sign\n    this._verify = opts.verify\n  } else {\n    this.id = id || u.createId()\n  }\n}\n\nvar sb = Scuttlebutt.prototype\n\nvar emit = EventEmitter.prototype.emit\n\nsb.applyUpdate = dutyOfSubclass\nsb.history      = dutyOfSubclass\n\nsb.localUpdate = function (trx) {\n  this._update([trx, timestamp(), this.id])\n  return this\n}\n\nsb._update = function (update) {\n  var ts = update[1]\n  var source = update[2]\n  //if this message is old for it's source,\n  //ignore it. it's out of order.\n  //each node must emit it's changes in order!\n  \n  var latest = this.sources[source]\n  if(latest && latest >= ts)\n    return emit.call(this, 'old_data', update), false\n\n  this.sources[source] = ts\n\n  var self = this\n  function didVerification (err, verified) {\n\n    // I'm not sure how what should happen if a async verification\n    // errors. if it's an key not found - that is a verification fail,\n    // not a error. if it's genunie error, really you should queue and \n    // try again? or replay the message later\n    // -- this should be done my the security plugin though, not scuttlebutt.\n\n    if(err)\n      return emit.call(self, 'error', err)\n\n    if(!verified)\n      return emit.call(self, 'unverified_data', update)\n\n    // check if this message is older than\n    // the value we already have.\n    // do nothing if so\n    // emit an 'old_data' event because i'll want to track how many\n    // unnecessary messages are sent.\n\n    if(self.applyUpdate(update))\n      emit.call(self, '_update', update) //write to stream.\n\n  }\n\n  if(source !== this.id) {\n    if(this._verify)\n      this._verify(update, didVerification)\n    else\n      didVerification(null, true)\n  } else {\n    if(this._sign) {\n      //could make this async easily enough.\n      update[3] = this._sign(update)\n    }\n    didVerification(null, true)\n  }\n\n  return true\n}\n\nsb.createStream = function (opts) {\n  var self = this\n  //the sources for the remote end.\n  var sources = {}, other\n  var syncSent = false, syncRecv = false\n\n  this._streams ++\n\n  opts = opts || {}\n  var d = duplex()\n  d.name = opts.name\n  var outer = serializer(opts && opts.wrapper)(d)\n  outer.inner = d\n\n  d.writable = opts.writable !== false\n  d.readable = opts.readable !== false\n\n  syncRecv   = !d.writable\n  syncSent   = !d.readable\n\n  var tail = opts.tail !== false //default to tail=true\n\n  function start (data) {\n    //when the digest is recieved from the other end,\n    //send the history.\n    //merge with the current list of sources.\n    sources = data.clock\n    i.each(self.history(sources), function (data) {d._data(data)})\n    \n    outer.emit('header', data)\n    d._data('SYNC')\n    //when we have sent all history\n    outer.emit('syncSent')\n    syncSent = true\n    //when we have recieved all histoyr\n    //emit 'synced' when this stream has synced.\n    if(syncRecv) outer.emit('sync'), outer.emit('synced')\n    if(!tail) d._end()\n  }\n\n  d\n    .on('_data', function (data) {\n      //if it's an array, it's an update.\n      if(Array.isArray(data)) {\n        if(validate(data))\n          return self._update(data)\n      }\n      //if it's an object, it's a scuttlebut digest.\n      else if('object' === typeof data && data)\n        start(data)\n      else if('string' === typeof data && data == 'SYNC') {\n        syncRecv = true\n        outer.emit('syncRecieved')\n        if(syncSent) outer.emit('sync'), outer.emit('synced')\n      }\n    }).on('_end', function () {\n      d._end()\n    })\n    .on('close', function () {\n      self.removeListener('_update', onUpdate)\n      //emit the number of streams that are remaining...\n      //this will be used for memory management...\n      self._streams --\n      emit.call(self, 'unstream', self._streams)\n    })\n\n  if(opts && opts.tail === false) {\n    outer.on('sync', function () {\n      process.nextTick(function () {\n        d._end()\n      })\n    })\n  }\n  function onUpdate (update) { //key, value, source, ts\n    if(!u.filter(update, sources))\n      return\n\n    d._data(update)\n\n    //really, this should happen before emitting.\n    var ts = update[1]\n    var source = update[2]\n    sources[source] = ts\n  }\n\n  var outgoing = { id : self.id, clock : self.sources }\n\n  if (opts && opts.meta) outgoing.meta = opts.meta\n\n  if(d.readable) {\n    d._data(outgoing)\n    if(!d.writable)\n      start({clock:{}})\n    if(tail)\n      self.on('_update', onUpdate)\n  }\n\n  self.once('dispose', function () {\n    d.end()\n  })\n\n  return outer\n}\n\nsb.createWriteStream = function (opts) {\n  opts = opts || {}\n  opts.writable = true; opts.readable = false\n  return this.createStream(opts)\n}\n\nsb.createReadStream = function (opts) {\n  opts = opts || {}\n  opts.writable = false; opts.readable = true\n  return this.createStream(opts)\n}\n\nsb.dispose = function () {\n  emit.call(this, 'dispose')\n}\n\nsb.setId = function (id) {\n  this.id = id\n  return this\n}\n\n//create another instance of this scuttlebutt,\n//that is in sync and attached to this instance.\nsb.clone = function () {\n  var A = this\n  var B = new (A.constructor)\n  B.setId(A.id) //same id. think this will work...\n\n  var a = A.createStream({wrapper: 'raw'})\n  var b = B.createStream({wrapper: 'raw'})\n\n  //all updates must be sync, so make sure pause never happens.\n  a.pause = b.pause = function noop(){}\n\n  a.pipe(b).pipe(a)\n  //resume both streams, so that the new instance is brought up to date immediately.\n  a.resume()\n  b.resume()\n\n  return B\n}\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//\n// adds all the fields from obj2 onto obj1\n//\n\nvar each = exports.each = function (obj,iterator){\n var keys = Object.keys(obj)\n keys.forEach(function (key){\n  iterator(obj[key],key,obj) \n })\n}\n\nvar RX = /sadf/.constructor\nfunction rx (iterator ){\n  return iterator instanceof RX ? function (str) { \n      var m = iterator.exec(str)\n      return m && (m[1] ? m[1] : m[0]) \n    } : iterator\n}\n\nvar times = exports.times = function () {\n  var args = [].slice.call(arguments)\n    , iterator = rx(args.pop())\n    , m = args.pop()\n    , i = args.shift()\n    , j = args.shift()\n    , diff, dir\n    , a = []\n    \n    i = 'number' === typeof i ? i : 1\n    diff = j ? j - i : 1\n    dir = i < m\n    if(m == i)\n      throw new Error('steps cannot be the same: '+m+', '+i)\n  for (; dir ? i <= m : m <= i; i += diff)\n    a.push(iterator(i))\n  return a\n}\n\nvar map = exports.map = function (obj, iterator){\n  iterator = rx(iterator)\n  if(Array.isArray(obj))\n    return obj.map(iterator)\n  if('number' === typeof obj)\n    return times.apply(null, [].slice.call(arguments))  \n  //return if null ?  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    r[key] = iterator(obj[key],key,obj) \n  })\n  return r\n}\n\nvar findReturn = exports.findReturn = function (obj, iterator) {\n  iterator = rx(iterator)\n  if(obj == null)\n    return\n  var keys = Object.keys(obj)\n    , l = keys.length\n  for (var i = 0; i < l; i ++) {\n    var key = keys[i]\n      , value = obj[key]\n    var r = iterator(value, key)\n    if(r) return r\n  }\n}\n\nvar find = exports.find = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return v\n  })\n}\n\nvar findKey = exports.findKey = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return k\n  })\n}\n\nvar filter = exports.filter = function (obj, iterator){\n  iterator = rx (iterator)\n\n  if(Array.isArray(obj))\n    return obj.filter(iterator)\n  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    var v\n    if(iterator(v = obj[key],key,obj))\n      r[key] = v\n  })\n  return r \n}\n\nvar mapKeys = exports.mapKeys = function (ary, iterator){\n  var r = {}\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r[v] = iterator(v,k)\n  })\n  return r\n}\n\n\nvar mapToArray = exports.mapToArray = function (ary, iterator){\n  var r = []\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r.push(iterator(v,k))\n  })\n  return r\n}\n\nvar path = exports.path = function (object, path) {\n\n  for (var i in path) {\n    if(object == null) return undefined\n    var key = path[i]\n    object = object[key]\n  }\n  return object\n}\n\n/*\nNOTE: naive implementation. \n`match` must not contain circular references.\n*/\n\nvar setPath = exports.setPath = function (object, path, value) {\n\n  for (var i in path) {\n    var key = path[i]\n    if(object[key] == null) object[key] = ( \n      i + 1 == path.length ? value : {}\n    )\n    object = object[key]\n  }\n}\n\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/util.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.createId = \nfunction () {\n  return [1,1,1].map(function () {\n    return Math.random().toString(16).substring(2).toUpperCase()\n  }).join('')\n}\n\nexports.filter = function (update, sources) {\n  var ts = update[1]\n  var source = update[2]\n  return (!sources || !sources[source] || sources[source] < ts)\n}\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/util.js"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _last = 0\nvar _count = 1\nvar LAST\n\nmodule.exports = \nfunction () {\n  var t = Date.now()\n  var _t = t\n  if(_last == t) {\n    _t += ((_count++)/1000) \n  } \n  else _count = 1 \n\n  _last = t\n\n  if(_t === LAST)\n    throw new Error('LAST:' + LAST + ',' + _t)\n  LAST = _t\n  return _t\n}\n\n\n//@ sourceURL=/node_modules/r-edit/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js"
));

require.define("/node_modules/r-array/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar between     = require('between')\nvar Scuttlebutt = require('scuttlebutt')\nvar inherits    = require('util').inherits\nvar filter      = require('scuttlebutt/util').filter\n\ninherits(RArray, Scuttlebutt)\n\nmodule.exports = RArray\n\nfunction fuzz () {\n  return Math.random().toString().substring(2, 5)\n}\n\nvar DOEMIT = true, CHANGE = {}\n\nfunction order (a, b) {\n  //timestamp, then source\n  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])\n}\n\nfunction RArray () {\n  Scuttlebutt.call(this)\n  this.keys = []\n  this.store = {}\n  this._hist = {}\n  this.length = 0\n  if(arguments.length) {\n    var self = this\n    ;[].forEach.call(arguments, function (e) {\n      self.push(e)\n    })\n  }\n}\n\nvar A = RArray.prototype\n\nA.last = function () {\n  return this.keys[this.keys.length - 1]\n}\n\nA.first = function () {\n  return this.keys[0]\n}\n\nA.insert = function (before, val, after) {  \n  var key = between(before || between.lo, after || between.hi) + fuzz()\n  this.set(key, val)\n  return key\n}\n\nA.push = function (val) {\n  var key = this.insert(this.last(), val)\n}\n\nA.unshift = function (val) {\n  var key = this.insert(null, val, this.first())\n}\n\nA.indexOf = function (val) {\n  for(var i in this.keys) {\n    var key = this.keys[i]\n    if(v === this.get(key)) return i\n  }\n  return null\n}\n\nA.indexOfKey = function (key) {\n  return this.keys.indexOf(key)\n}\n\nA.toJSON = function () {\n  var store = this.store\n  var self = this\n  return this.keys.map(function (key) {\n    return self.get(key)\n  })\n}\n\nA.set = function (key, val) {\n  if('string' == typeof key) {\n    if(val === null) return this.unset(key)\n    if(null == this.store[key]) this.length ++\n    this.store[key] = val\n    if(!~this.keys.indexOf(key)) {\n      this.keys.push(key)\n      this.keys.sort()\n    }\n    CHANGE[key] = val\n    DOEMIT && this._emit()\n  }\n}\n\nA.get = function (key) {\n  return this.store[key]\n}\n\nA.unset = function (key) {\n  if('string' == typeof key) {\n    if(null != this.store[key]) this.length --\n    delete this.store[key]\n    var i = this.keys.indexOf(key)\n    if(!~i) return\n    this.keys.splice(i, 1)    \n\n    CHANGE[key] = null\n    DOEMIT && this._emit()\n  }\n}\n\nA.pop = function () {\n  var l = this.last()\n  var val = this.store[l]\n  this.unset(l)\n  return val\n}\n\nA.shift = function () {\n  var f = this.first()\n  var val = this.store[f]\n  this.unset(f)\n  return val\n}\n\nA._emit = function () {\n  if(!DOEMIT) return\n  this.localUpdate(CHANGE)\n  CHANGE = {}\n}\n\nA.splice = function (i, d /*,...args*/) {\n  var args = [].slice.call(arguments, 2)\n  var j = 0, l = args.length\n\n  DOEMIT = false\n\n  if(d + i > this.keys.length)\n    d = this.keys.length - i\n  \n  while(j < d) {\n    if(j < l)\n      this.set(this.keys[i+j], args[j]), j++\n    else\n      this.unset(this.keys[i+j]), d--\n  }\n\n  while(j < l)\n    this.insert(this.keys[i+j-1], args[j], this.keys[i+j]), j++\n\n  DOEMIT = true\n  this._emit()\n}\n\nA.applyUpdate = function (update) {\n  DOEMIT = false\n  var change = update[0], old\n  var apply = {}, ch = {}\n  var old = {}\n  for(var key in change) {\n    if(!this._hist[key] || order(update, this._hist[key]) > 0)\n      apply[key] = change[key]\n  }\n  //allow the user to see what the change is going to be.\n  this.emit('preupdate', apply) \n\n  //apply the change...\n  for(var key in apply) {\n    var o = this._hist[key]\n    o && (old[o[1]+':'+o[2]] = o) //ts:source\n    this._hist[key] = update\n    this.set(key, apply[key])\n  }\n\n  //check if old elements need to be removed.\n  //may also want to keep old updates hanging around \n  //so the user can see recent history...\n  for(var id in old) {\n    var o = old[id][0], rm = true\n    for(var key in o) {\n      if(this._hist[key] === old[id]) rm = false\n    }\n    if(rm)\n      this.emit('_remove', old[id])\n  }\n    \n  DOEMIT = true\n  CHANGE = {}\n  this.emit('update', apply)\n  return true\n}\n\n\nA.history = function (sources) {\n  var h = []\n  for (var key in this._hist) {\n    var update = this._hist[key]\n      if(!~h.indexOf(update) && filter(update, sources))\n        h.push(update)\n  }\n  return h.sort(order)\n}\n\nA.forEach = function (fun) {\n  return this.toJSON().forEach(fun)\n}\n\nA.filter = function (fun) {\n  return this.toJSON().filter(fun)\n}\n\nA.map = function (fun) {\n  return this.toJSON().map(fun)\n}\n\nA.reduce = function (fun, initial) {\n  return this.toJSON().reduce(fun, initial)\n}\n\n\n//@ sourceURL=/node_modules/r-array/index.js"
));

require.define("/node_modules/r-array/node_modules/between/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/node_modules/between/package.json"
));

require.define("/node_modules/r-array/node_modules/between/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction inject (chars) {\n\n  chars = chars ||\n  '!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'\n\n  chars = chars.split('').sort().join('')\n\n  var exports = between\n\n  exports.between   = between\n\n  exports.randstr   = randstr\n  exports.between   = between\n  exports.strord    = strord\n\n  exports.lo        = chars[0]\n  exports.hi        = chars[chars.length - 1]\n\n  exports.inject    = inject\n\n  function randstr(l) {\n    var str = ''\n    while(l--) \n      str += chars[\n        Math.floor(\n          Math.random() * chars.length \n        )\n      ]\n    return str\n  }\n\n  /*\n    SOME EXAMPLE STRINGS, IN ORDER\n   \n    0\n    00001\n    0001\n    001\n    001001\n    00101\n    0011\n    0011001\n    001100101\n    00110011\n    001101\n    00111\n    01  \n\n    if you never make a string that ends in the lowest char,\n    then it is always possible to make a string between two strings.\n    this is like how decimals never end in 0. \n\n    example:\n\n    between('A', 'AB') \n\n    ... 'AA' will sort between 'A' and 'AB' but then it is impossible\n    to make a string inbetween 'A' and 'AA'.\n    instead, return 'AAB', then there will be space.\n\n  */\n\n  function between (a, b) {\n\n    var s = '', i = 0\n\n    while (true) {\n\n      var _a = chars.indexOf(a[i])\n      var _b = chars.indexOf(b[i])\n     \n      if(_a == -1) _a = 0\n      if(_b == -1) _b = chars.length - 1\n\n      i++\n\n      var c = chars[\n          _a + 1 < _b \n        ? Math.round((_a+_b)/2)\n        : _a\n      ]\n\n      s += c\n\n      if(a < s && s < b && c != exports.lo)\n        return s;\n    }\n  }\n\n  function strord (a, b) {\n    return (\n      a == b ?  0\n    : a <  b ? -1\n    :           1\n    )\n  }\n\n  between.strord\n\n  return between\n}\n\n\nmodule.exports = inject(null)\n\n//@ sourceURL=/node_modules/r-array/node_modules/between/index.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/package.json"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar i = require('iterate')\nvar duplex = require('duplex')\nvar inherits = require('util').inherits\nvar serializer = require('stream-serializer')\nvar u = require('./util')\nvar timestamp = require('monotonic-timestamp')\n\nexports = \nmodule.exports = Scuttlebutt\n\nexports.createID = u.createID\nexports.updateIsRecent = u.filter\nexports.filter = u.filter\nexports.timestamp = timestamp\n\nfunction dutyOfSubclass() {\n  throw new Error('method must be implemented by subclass')\n}\n\nfunction validate (data) {\n  var ts = data[1], source = data[2]\n\n  if(  !Array.isArray(data) \n    || 'string'    !== typeof source\n    || 'number'    !== typeof ts\n  ) return false\n\n  return true\n}\n\nvar emit = EventEmitter.prototype.emit\n\ninherits (Scuttlebutt, EventEmitter)\n\nfunction Scuttlebutt (opts) {\n\n  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)\n  var id = 'string' === typeof opts ? opts : opts && opts.id\n  this.sources = {}\n  this.setMaxListeners(Number.MAX_VALUE)\n  //count how many other instances we are replicating to.\n  this._streams = 0\n  if(opts && opts.sign && opts.verify) {\n    this.id      = opts.id || opts.createId()\n    this._sign   = opts.sign\n    this._verify = opts.verify\n  } else {\n    this.id = id || u.createId()\n  }\n}\n\nvar sb = Scuttlebutt.prototype\n\nvar emit = EventEmitter.prototype.emit\n\nsb.applyUpdate = dutyOfSubclass\nsb.history      = dutyOfSubclass\n\nsb.localUpdate = function (trx) {\n  this._update([trx, timestamp(), this.id])\n  return this\n}\n\nsb._update = function (update) {\n  var ts = update[1]\n  var source = update[2]\n  //if this message is old for it's source,\n  //ignore it. it's out of order.\n  //each node must emit it's changes in order!\n  \n  var latest = this.sources[source]\n  if(latest && latest >= ts)\n    return emit.call(this, 'old_data', update), false\n\n  this.sources[source] = ts\n\n  var self = this\n  function didVerification (err, verified) {\n\n    // I'm not sure how what should happen if a async verification\n    // errors. if it's an key not found - that is a verification fail,\n    // not a error. if it's genunie error, really you should queue and \n    // try again? or replay the message later\n    // -- this should be done my the security plugin though, not scuttlebutt.\n\n    if(err)\n      return emit.call(self, 'error', err)\n\n    if(!verified)\n      return emit.call(self, 'unverified_data', update)\n\n    // check if this message is older than\n    // the value we already have.\n    // do nothing if so\n    // emit an 'old_data' event because i'll want to track how many\n    // unnecessary messages are sent.\n\n    if(self.applyUpdate(update))\n      emit.call(self, '_update', update) //write to stream.\n\n  }\n\n  if(source !== this.id) {\n    if(this._verify)\n      this._verify(update, didVerification)\n    else\n      didVerification(null, true)\n  } else {\n    if(this._sign) {\n      //could make this async easily enough.\n      update[3] = this._sign(update)\n    }\n    didVerification(null, true)\n  }\n\n  return true\n}\n\nsb.createStream = function (opts) {\n  var self = this\n  //the sources for the remote end.\n  var sources = {}, other\n  var syncSent = false, syncRecv = false\n\n  this._streams ++\n\n  opts = opts || {}\n  var d = duplex()\n  d.name = opts.name\n  var outer = serializer(opts && opts.wrapper)(d)\n  outer.inner = d\n\n  d.writable = opts.writable !== false\n  d.readable = opts.readable !== false\n\n  syncRecv   = !d.writable\n  syncSent   = !d.readable\n\n  var tail = opts.tail !== false //default to tail=true\n\n  function start (data) {\n    //when the digest is recieved from the other end,\n    //send the history.\n    //merge with the current list of sources.\n    sources = data.clock\n    i.each(self.history(sources), function (data) {d._data(data)})\n    \n    outer.emit('header', data)\n    d._data('SYNC')\n    //when we have sent all history\n    outer.emit('syncSent')\n    syncSent = true\n    //when we have recieved all histoyr\n    //emit 'synced' when this stream has synced.\n    if(syncRecv) outer.emit('sync'), outer.emit('synced')\n    if(!tail) d._end()\n  }\n\n  d\n    .on('_data', function (data) {\n      //if it's an array, it's an update.\n      if(Array.isArray(data)) {\n        if(validate(data))\n          return self._update(data)\n      }\n      //if it's an object, it's a scuttlebut digest.\n      else if('object' === typeof data && data)\n        start(data)\n      else if('string' === typeof data && data == 'SYNC') {\n        syncRecv = true\n        outer.emit('syncRecieved')\n        if(syncSent) outer.emit('sync'), outer.emit('synced')\n      }\n    }).on('_end', function () {\n      d._end()\n    })\n    .on('close', function () {\n      self.removeListener('_update', onUpdate)\n      //emit the number of streams that are remaining...\n      //this will be used for memory management...\n      self._streams --\n      emit.call(self, 'unstream', self._streams)\n    })\n\n  if(opts && opts.tail === false) {\n    outer.on('sync', function () {\n      process.nextTick(function () {\n        d._end()\n      })\n    })\n  }\n  function onUpdate (update) { //key, value, source, ts\n    if(!u.filter(update, sources))\n      return\n\n    d._data(update)\n\n    //really, this should happen before emitting.\n    var ts = update[1]\n    var source = update[2]\n    sources[source] = ts\n  }\n\n  var outgoing = { id : self.id, clock : self.sources }\n\n  if (opts && opts.meta) outgoing.meta = opts.meta\n\n  if(d.readable) {\n    d._data(outgoing)\n    if(!d.writable)\n      start({clock:{}})\n    if(tail)\n      self.on('_update', onUpdate)\n  }\n\n  self.once('dispose', function () {\n    d.end()\n  })\n\n  return outer\n}\n\nsb.createWriteStream = function (opts) {\n  opts = opts || {}\n  opts.writable = true; opts.readable = false\n  return this.createStream(opts)\n}\n\nsb.createReadStream = function (opts) {\n  opts = opts || {}\n  opts.writable = false; opts.readable = true\n  return this.createStream(opts)\n}\n\nsb.dispose = function () {\n  emit.call(this, 'dispose')\n}\n\nsb.setId = function (id) {\n  this.id = id\n  return this\n}\n\n//create another instance of this scuttlebutt,\n//that is in sync and attached to this instance.\nsb.clone = function () {\n  var A = this\n  var B = new (A.constructor)\n  B.setId(A.id) //same id. think this will work...\n\n  var a = A.createStream({wrapper: 'raw'})\n  var b = B.createStream({wrapper: 'raw'})\n\n  //all updates must be sync, so make sure pause never happens.\n  a.pause = b.pause = function noop(){}\n\n  a.pipe(b).pipe(a)\n  //resume both streams, so that the new instance is brought up to date immediately.\n  a.resume()\n  b.resume()\n\n  return B\n}\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/index.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/package.json"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//\n// adds all the fields from obj2 onto obj1\n//\n\nvar each = exports.each = function (obj,iterator){\n var keys = Object.keys(obj)\n keys.forEach(function (key){\n  iterator(obj[key],key,obj) \n })\n}\n\nvar RX = /sadf/.constructor\nfunction rx (iterator ){\n  return iterator instanceof RX ? function (str) { \n      var m = iterator.exec(str)\n      return m && (m[1] ? m[1] : m[0]) \n    } : iterator\n}\n\nvar times = exports.times = function () {\n  var args = [].slice.call(arguments)\n    , iterator = rx(args.pop())\n    , m = args.pop()\n    , i = args.shift()\n    , j = args.shift()\n    , diff, dir\n    , a = []\n    \n    i = 'number' === typeof i ? i : 1\n    diff = j ? j - i : 1\n    dir = i < m\n    if(m == i)\n      throw new Error('steps cannot be the same: '+m+', '+i)\n  for (; dir ? i <= m : m <= i; i += diff)\n    a.push(iterator(i))\n  return a\n}\n\nvar map = exports.map = function (obj, iterator){\n  iterator = rx(iterator)\n  if(Array.isArray(obj))\n    return obj.map(iterator)\n  if('number' === typeof obj)\n    return times.apply(null, [].slice.call(arguments))  \n  //return if null ?  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    r[key] = iterator(obj[key],key,obj) \n  })\n  return r\n}\n\nvar findReturn = exports.findReturn = function (obj, iterator) {\n  iterator = rx(iterator)\n  if(obj == null)\n    return\n  var keys = Object.keys(obj)\n    , l = keys.length\n  for (var i = 0; i < l; i ++) {\n    var key = keys[i]\n      , value = obj[key]\n    var r = iterator(value, key)\n    if(r) return r\n  }\n}\n\nvar find = exports.find = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return v\n  })\n}\n\nvar findKey = exports.findKey = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return k\n  })\n}\n\nvar filter = exports.filter = function (obj, iterator){\n  iterator = rx (iterator)\n\n  if(Array.isArray(obj))\n    return obj.filter(iterator)\n  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    var v\n    if(iterator(v = obj[key],key,obj))\n      r[key] = v\n  })\n  return r \n}\n\nvar mapKeys = exports.mapKeys = function (ary, iterator){\n  var r = {}\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r[v] = iterator(v,k)\n  })\n  return r\n}\n\n\nvar mapToArray = exports.mapToArray = function (ary, iterator){\n  var r = []\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r.push(iterator(v,k))\n  })\n  return r\n}\n\nvar path = exports.path = function (object, path) {\n\n  for (var i in path) {\n    if(object == null) return undefined\n    var key = path[i]\n    object = object[key]\n  }\n  return object\n}\n\n/*\nNOTE: naive implementation. \n`match` must not contain circular references.\n*/\n\nvar setPath = exports.setPath = function (object, path, value) {\n\n  for (var i in path) {\n    var key = path[i]\n    if(object[key] == null) object[key] = ( \n      i + 1 == path.length ? value : {}\n    )\n    object = object[key]\n  }\n}\n\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/iterate/index.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/util.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.createId = \nfunction () {\n  return [1,1,1].map(function () {\n    return Math.random().toString(16).substring(2).toUpperCase()\n  }).join('')\n}\n\nexports.filter = function (update, sources) {\n  var ts = update[1]\n  var source = update[2]\n  return (!sources || !sources[source] || sources[source] < ts)\n}\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/util.js"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _last = 0\nvar _count = 1\nvar LAST\n\nmodule.exports = \nfunction () {\n  var t = Date.now()\n  var _t = t\n  if(_last == t) {\n    _t += ((_count++)/1000) \n  } \n  else _count = 1 \n\n  _last = t\n\n  if(_t === LAST)\n    throw new Error('LAST:' + LAST + ',' + _t)\n  LAST = _t\n  return _t\n}\n\n\n//@ sourceURL=/node_modules/r-array/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/package.json"
));

require.define("/node_modules/rumours/node_modules/crdt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//index\n'use strict';\n\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = require('./doc')\nexports.Row              = require('./row')\n\nexports.sync             = sync\nexports.Set              = require('./set')\nexports.Seq              = require('./seq')\n\nexports.Doc = exports\n\nfunction sync(a, b) {\n  var as = a.createStream()\n  var bs = b.createStream()\n  return as.pipe(bs).pipe(as)\n}\n\n\nexports.createStream = function (doc, opts) {\n  return doc.createStream(opts)\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/doc.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var inherits     = require('util').inherits\nvar Row          = require('./row')\nvar between      = require('between')\nvar Set          = require('./set')\nvar Seq          = require('./seq')\nvar Scuttlebutt  = require('scuttlebutt')\nvar EventEmitter = require('events').EventEmitter\nvar createId     = require('scuttlebutt/util').createId\n\ninherits(Doc, Scuttlebutt)\n\nfunction merge(to, from) {\n  for(var k in from)\n    to[k] = from[k]\n  return to\n}\n\n\nmodule.exports = Doc\n//doc\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/*\n  idea: instead of using a tombstone for deletes,\n  use a anti-tombstone to show something is alive.\n  breathing: count. -- updated by an authority.\n  set breathing to 0 to kill something.\n  \n  if a node has rows that have been garbage collected on the server,\n  it will be obvious from the value of breathing.\n\n  node disconnects... makes changes...\n  other nodes delete some things, which get garbage collected.\n\n  node reconnects.\n  server updates the node, but only increments _breathing for some rows.\n  \n  clearly, the nodes that do not have an upto date _breathing are either\n  dead, or where created by the node while it was offline.\n\n  would breathing need to be a vector clock?\n  \n  if the disconneded node is still updating the rows,\n  maybe it shouldn't be deleted, that is, undeleted.\n\n  may be on to something here... but this needs more thinking.\n\n  will depend on how much churn something has...\n*/\n\nfunction order (a, b) {\n  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])\n}\n\nfunction Doc (id) {\n  if (!(this instanceof Doc)) return new Doc(id)\n  //the id of the doc refers to the instance.\n  //that is, to the node.\n  //it's used to identify a node \n//  this.id = id || '#' + Math.round(Math.random()*1000)\n  this.rows = {}\n  this.hist = {}\n  this.recieved = {}\n  this.sets = new EventEmitter() //for tracking membership of sets.\n  this.setMaxListeners(Infinity)\n  this.sets.setMaxListeners(Infinity)\n  Scuttlebutt.call(this, id)\n\n}\n\nDoc.prototype.add = function (initial) {\n  var id = initial.id === undefined ? createId() : initial.id\n  var r = this._add(id, 'local')\n  r._set(initial, 'local')\n  return r\n}\n\nDoc.prototype._add = function (id, source, change) {\n\n  var doc = this\n\n  if(this.rows[id])\n    return this.rows[id]\n\n  var r = id instanceof Row ? id : new Row(id)\n  this.rows[r.id] = r\n\n  function track (changes, source) {\n    doc.localUpdate([r.id, changes])\n  }\n\n  r.on('preupdate', track)\n\n  r._new = true\n  return r\n}\n\nDoc.prototype.timeUpdated = function (row, key) {\n  var h = this.hist[row.id] \n  if(!h) return\n  return h[key][2]\n}\n\nDoc.prototype.set = function (id, change) {\n  var r = this._add(id, 'local', change)\n  return r.set(change)\n}\n\n/*\n  histroy for each row is indexed by key.\n  key -> update that set that key.\n\n  so applying a change is as simple\n  as iterating over the keys in the rows hist\n  checking if the new update is more recent\n  than the hist update\n  if so, replace that keys hist.\n*/\n\nDoc.prototype.applyUpdate = function (update, source) {\n\n  //apply an update to a row.\n  //take into account histroy.\n  //and insert the change into the correct place.\n  var id      = update[0][0]\n  var changes = update[0][1]\n  var timestamp = update[1]\n  var from    = update[2]\n\n  var changed = {}\n\n  var row = this._add(id, source)\n  var hist = this.hist[id] = this.hist[id] || {}\n  var emit = false, oldnews = false\n\n\n  //remember the most recent update from each node.\n  //now handled my scuttlebutt.\n//  if(!row.validate(changes)) return\n  \n  for(var key in changes) {\n    var value = changes[key]\n    if(!hist[key] || order(hist[key], update) < 0) {\n      if(hist[key]) this.emit('_remove', hist[key])\n      hist[key] = update\n      changed[key] = changes[key]\n      emit = true \n    }\n  }\n\n//  probably, there may be mulitple sets that listen to the same key, \n//  but activate on different values...\n//\n//  hang on, in the mean time, I will probably only be managing n < 10 sets. \n//  at once, \n\n  merge(row.state, changed)\n  for(var k in changed)\n    this.sets.emit(k, row, changed) \n  \n  if(!emit) return\n  \n  if(row._new) {\n    this.emit('add', row)\n    this.emit('create', row) //alias\n    row._new = false\n  }\n  this.emit('_update', update)\n  row.emit('update', update, changed)\n  row.emit('changes', changes, changed)\n  row.emit('change', changed) //installing this in paralel, so tests still pass.\n  //will depreciate the old way later.\n  this.emit('update', update, source)   //rename this event to 'data' or 'diff'?\n  this.emit('row_update', row)          //rename this event to 'update'\n}\n\nDoc.prototype.history = function (sources) {\n  var h = []\n  for (var id in this.hist) {\n    var hist = this.hist[id]\n    for (var k in hist) {\n      if(!~h.indexOf(hist[k]) && Scuttlebutt.filter(hist[k], sources))\n        h.push(hist[k])\n    }\n  }\n  return h.sort(order)\n}\n\nfunction _set(self, key, val, type) {\n   var id = key + ':' + val\n  if(self.sets[id]) return self.sets[id] \n  return self.sets[key + ':' + val] = new type(self, key, val) \n}\n\nDoc.prototype.createSet = function (key, val) {\n  return _set(this, key, val, Set)\n}\n\nDoc.prototype.createSeq = function (key, val) {\n  return _set(this, key, val, Seq)\n}\n\nDoc.prototype.toJSON = function () {\n  var j = {}\n  for (var k in this.rows)\n    j[k] = this.rows[k].state\n  return j\n}\n//retrive a reference to a row.\n//if the row is not created yet, create \nDoc.prototype.get = function (id) {\n  return this.rows[id] = this.rows[id] || this._add(new Row(id), 'local')\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/doc.js"
));

require.define("/node_modules/rumours/node_modules/crdt/row.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//row\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'use strict';\n\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = Row\n\ninherits(Row, EventEmitter)\n\nfunction Row (id) {\n  this.id = id\n  this.state = {id: id}\n  this.setMaxListeners(Infinity)\n}\n\nRow.prototype.set = function (changes, v) {\n  if(arguments.length == 2) {\n    var k = changes \n    changes = {}\n    changes[k] = v\n  }\n\n  if(changes.id && changes.id !== this.state.id)\n    throw new Error('id cannot be changed')\n\n  this._set(changes, 'local')  \n  return this\n}\n\nRow.prototype.validate = function (changes) {\n  try {\n    this.emit('validate', changes)\n    return true\n  } catch (e) {\n    console.error('validation', e.message)\n    return false\n  } \n}\n\nRow.prototype._set = function (changes, source) {\n\n  //the change is applied by the Doc!\n  this.emit('preupdate', changes, source)\n  return this\n}\n\nRow.prototype.get = function (key) {\n  if(key)\n    return this.state[key]\n  return this.state\n}\n\nRow.prototype.toJSON = function () {\n  return this.state\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/row.js"
));

require.define("/node_modules/rumours/node_modules/crdt/node_modules/between/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/node_modules/between/package.json"
));

require.define("/node_modules/rumours/node_modules/crdt/node_modules/between/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction inject (chars) {\n\n  chars = chars ||\n  '!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'\n\n  chars = chars.split('').sort().join('')\n\n  var exports = between\n\n  exports.between   = between\n\n  exports.randstr   = randstr\n  exports.between   = between\n  exports.strord    = strord\n\n  exports.lo        = chars[0]\n  exports.hi        = chars[chars.length - 1]\n\n  exports.inject    = inject\n\n  function randstr(l) {\n    var str = ''\n    while(l--) \n      str += chars[\n        Math.floor(\n          Math.random() * chars.length \n        )\n      ]\n    return str\n  }\n\n  /*\n    SOME EXAMPLE STRINGS, IN ORDER\n   \n    0\n    00001\n    0001\n    001\n    001001\n    00101\n    0011\n    0011001\n    001100101\n    00110011\n    001101\n    00111\n    01  \n\n    if you never make a string that ends in the lowest char,\n    then it is always possible to make a string between two strings.\n    this is like how decimals never end in 0. \n\n    example:\n\n    between('A', 'AB') \n\n    ... 'AA' will sort between 'A' and 'AB' but then it is impossible\n    to make a string inbetween 'A' and 'AA'.\n    instead, return 'AAB', then there will be space.\n\n  */\n\n  function between (a, b) {\n\n    var s = '', i = 0\n\n    while (true) {\n\n      var _a = chars.indexOf(a[i])\n      var _b = chars.indexOf(b[i])\n     \n      if(_a == -1) _a = 0\n      if(_b == -1) _b = chars.length - 1\n\n      i++\n\n      var c = chars[\n          _a + 1 < _b \n        ? Math.round((_a+_b)/2)\n        : _a\n      ]\n\n      s += c\n\n      if(a < s && s < b && c != exports.lo)\n        return s;\n    }\n  }\n\n  function strord (a, b) {\n    return (\n      a == b ?  0\n    : a <  b ? -1\n    :           1\n    )\n  }\n\n  between.strord\n\n  return between\n}\n\n\nmodule.exports = inject(null)\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/node_modules/between/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/set.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\nvar Row          = require('./row')\nvar between      = require('between')\n\ninherits(Set, EventEmitter)\n\nmodule.exports = Set\n\n//set\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/*\n  a set is just a query.\n  could expand this to enable replicating a subset of a document.\n  that could enable massive documents that are too large to fit in memory.\n  as long as they could be partitioned.\n\n  heh, join queries? or rather, recursive queries,\n  for when rows have sets.\n\n  that is my vibe. don't make a database you have to \n  _map_ to your application. pre-map the database.\n\n  could also specify sets like\n\n  //set of all things\n  {type: 'thing'}\n\n  //set of things with thier parts\n  { type: 'thing',\n    parts: {\n      parent_id: function (val) {return val == this.id}\n    }\n  }\n\n  or use map-reduces. remember, if the the reduce is \n  monotonic you don't have to remember each input.\n*/\n\n//TODO check if any currently existing items should be in the set. currently, one must create the set before recieving anything.\n\nfunction Set(doc, key, value) {\n  var array = this._array = []\n  var rows = this.rows =  {}\n  var set = this\n\n  //DO NOT CHANGE once you have created the set.\n  this.key = key\n  this.value = value\n\n  function add(row) {\n    array.push(row)\n    rows[row.id] = row\n    set.emit('add', row)\n\n    function remove (_, changed) {\n      if(row.state[key] === value) {\n        set.emit('changes', row, changed)\n        return\n      }\n      delete rows[row.id]\n      var i = array.indexOf(row)\n      if(~i) array.splice(i, 1)\n      set.emit('changes', row, changed)\n      set.emit('remove', row)\n      row.removeListener('changes', remove)\n    }\n\n    row.on('changes', remove)\n \n  }\n\n  doc.sets.on(key, function (row, changed) {\n    if(changed[key] !== value) return \n    add(row)\n  })\n\n  this.rm = this.remove = function (row) {\n    row = this.get(row) \n    if(!row) return\n    return row.set(key, null)\n  }\n\n  for(var id in doc.rows) {\n    var row = doc.get(id)\n    if(row.get(key) === value) add(row) \n  }\n\n  this.setMaxListeners(Infinity)\n\n}\n\nSet.prototype.asArray = function () {\n  return this._array\n}\n\nSet.prototype.toJSON = function () {\n  return this._array.map(function (e) {\n    return e.state\n  }).sort(function (a, b) {\n    return between.strord(a._sort || a.id, b._sort || b.id)\n  })\n}\n\nSet.prototype.each = \nSet.prototype.forEach = function (iter) {\n  return this._array.forEach(iter)\n}\n\nSet.prototype.get = function (id) {\n  if(!arguments.length)\n    return this.array\n  return (\n      'string' === typeof id ? this.rows[id] \n    : 'number' === typeof id ? this.rows[id] \n    : id && id.id            ? this.rows[id.id]\n    :                          null\n  )\n}\n\nSet.prototype.has = function (row) {\n  return this.get(row)\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/set.js"
));

require.define("/node_modules/rumours/node_modules/crdt/seq.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\n\nvar Set      = require('./set')\nvar Row      = require('./row')\nvar inherits = require('util').inherits\nvar between  = require('between')\n\nmodule.exports = Seq\n\nfunction sort (array) {\n  return array.sort(function (a, b) {\n    return between.strord(a.get('_sort'), b.get('_sort'))\n  })\n}\n\ninherits(Seq, Set)\n\nfunction find (obj, iter) {\n  \n  for(var k in obj) {\n    var v = obj[k]\n    if(iter(v, k, obj)) return v\n  }\n  return null\n}\n\nfunction Seq (doc, key, val) {\n\n  Set.call(this, doc, key, val)\n  var seq = this\n  this.on('changes', function (row, changes) {\n    if(!changes._sort) return\n    sort(seq._array)\n    //check if there is already an item with this sort key.\n    var prev = \n    find(seq._array, function (other) {\n      return other != row && other.get('_sort') == row.get('_sort')\n    })\n\n    //nudge it forward if it has the same key.    \n    if(prev)\n      seq.insert(row, prev, seq.next(row)) \n    else\n      seq.emit('move', row)\n  })\n  this.insert = function (obj, before, after) {\n\n    before = toKey(this.get(before) || '!')\n    after  = toKey(this.get(after)  || '~')\n\n    //must get id from the doc,\n    //because may be moving this item into this set.\n    if('string' === typeof obj)\n      obj = doc.rows[obj]\n\n    var _sort = \n       between.between(before, after ) \n     + between.randstr(3) //add a random tail so it's hard\n                    //to concurrently add two items with the\n                    //same sort.\n \n    var r, changes\n    if(obj instanceof Row) {\n      r = obj\n      changes = {_sort: _sort}\n      if(r.get(key) != val)\n        changes[key] = val\n      r.set(changes)\n    } else {\n      obj._sort = _sort\n      obj[key] = val\n      r = doc.set(id(obj), obj)\n    } \n    sort(this._array)\n    return r\n  }\n}\n\nfunction toKey (key) {\n\n  return (\n     'string' === typeof key ? key \n  :  key instanceof Row      ? key.get()._sort\n  :  key                     ? key._sort\n  : null\n  )\n\n}\n\n/*\n  items are relative to each other,\n  more like a linked list.\n  although it is possible to make an\n  index based interface, before after,\n  etc is more natural\n*/\n\nfunction max (ary, test, wantIndex) {\n  var max = null, _max = -1\n  if(!ary.length) return\n\n  for (var i = 0; i < ary.length; i++)\n    if(test(max, ary[i])) max = ary[_max = i]\n  return wantIndex ? _max : max\n}\n\nSeq.prototype.prev = function (key) {\n  key = toKey(this.get(key) || '~')\n  //find the greatest item that is less than `key`.\n  //since the list is kept in order,\n  //a binary search is used.\n  //think about that later\n  return max(this._array, function (M, m) {\n    if(toKey(m) < key)\n      return M ? toKey(m) > toKey(M) : true\n  })\n}\n\nSeq.prototype.next = function (key) {\n  key = toKey(this.get(key) || '!')\n  return max(this._array, function (M, m) {\n    if(toKey(m) > key)\n      return M ? toKey(m) < toKey(M) : true\n  })\n}\n\nfunction id(obj) {\n  return (obj.id \n  ||  obj._id \n  ||  '_' + Date.now() \n    + '_' + Math.round(Math.random()*1000)\n  )\n}\n\nSeq.prototype.before = function (obj, before) {\n  return this.insert(obj, this.prev(before), before)\n}\n\nSeq.prototype.after = function (obj, after) {\n  return this.insert(obj, after, this.next(after))\n}\n\nSeq.prototype.first = function () {\n  return this._array[0]\n}\n\nSeq.prototype.last = function () {\n  return this._array[this._array.length - 1]\n}\n\nSeq.prototype.indexOf = function (obj) {\n  return this._array.indexOf('string' == typeof obj ? this.rows[obj] : obj)\n}\n\nSeq.prototype.at = function (i) {\n  return this._array[i]\n}\n\nSeq.prototype.unshift = function (obj) {\n  return this.insert(obj, '!', this.first())\n}\n\nSeq.prototype.push = function (obj) {\n  return this.insert(obj, this.last(), '~') \n}\n\nSeq.prototype.length = function () {\n  return this._array.length\n}\n\nSeq.prototype.pop = function () {\n  return this.remove(this.last())\n}\n\nSeq.prototype.shift = function () {\n  return this.remove(this.first())\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/seq.js"
));

require.define("/node_modules/rumours/node_modules/append-only/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/append-only/package.json"
));

require.define("/node_modules/rumours/node_modules/append-only/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require(\"scuttlebutt\")\n    , filter = Scuttlebutt.filter\n    , inherits = require(\"util\").inherits\n\ninherits(AppendOnly, Scuttlebutt)\n\nvar proto = AppendOnly.prototype\n\nproto.push = push\nproto.remove = remove\nproto.applyUpdate = applyUpdate\nproto.history = history\nproto.toJSON = proto.createArray = createArray\n\nmodule.exports = AppendOnly\n\nfunction AppendOnly(options) {\n    if (! (this instanceof AppendOnly)) {\n        return new AppendOnly(options)\n    }\n\n    Scuttlebutt.call(this, options)\n\n    var store = this._store = []\n    this._hash = {}\n\n    this.on(\"_remove\", function (update, update2) {\n        var index = store.indexOf(update)\n        if (index !== -1) {\n            store.splice(index, 1)\n        }\n\n        index = store.indexOf(update2)\n        if (index !== -1) {\n            store.splice(index, 1)\n        }\n    })\n}\n\nfunction push(item) {\n    this.localUpdate({ push: item })\n}\n\nfunction remove(id) {\n    this.localUpdate({ remove: id.__id ? id.__id : id })\n}\n\nfunction toId (update) {\n    var ts = update[1]\n        , source = update[2]\n\n    return source + \":\" + ts\n}\n\nfunction applyUpdate(update) {\n    var value = update[0]\n\n    this._store.push(update)\n\n    if (value.push) {\n        var item = value.push\n            , id = toId(update)\n\n        Object.defineProperty(item, \"__id\", {\n            value: id\n            , configurable: true\n        })\n        this._hash[id] = update\n        this.emit(\"item\", item)\n    } else if (value.remove) {\n        var id = value.remove\n            , _update = this._hash[id]\n\n        ;delete this._hash[id]\n\n        this.emit(\"_remove\", _update, update)\n        this.emit(\"remove\", _update[0].push)\n    }\n    return true\n}\n\nfunction history(sources) {\n    return this._store.filter(function (update) {\n        return filter(update, sources)\n    })\n}\n\nfunction createArray() {\n    var hash = this._hash\n\n    return Object.keys(hash).map(findKey, hash)\n}\n\nfunction findKey(key) {\n    return this[key][0].push\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/append-only/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require(\"scuttlebutt\")\nvar extend = require(\"xtend\")\nvar LRU = require(\"lru-cache\")\nvar filter = Scuttlebutt.filter\n\nvar DAY = 1000 * 60 * 60 * 24\nvar defaults = {\n    max: 500\n    , maxAge: DAY\n}\n\nmodule.exports = ExpiryModel\n\nfunction ExpiryModel(options) {\n    options = extend({}, defaults, options || {})\n\n    if (!options.dispose) {\n        options.dispose = dispose\n    }\n\n    var scuttle = Scuttlebutt()\n    var maxAge = options.maxAge\n    var store = LRU(options)\n\n    scuttle.set = set\n    scuttle.get = get\n    scuttle.applyUpdate = applyUpdate\n    scuttle.toJSON = toJSON\n    scuttle.history = history\n\n    return scuttle\n\n    function dispose(key, value) {\n        var source = value[2]\n        var found = false\n\n        store.forEach(function (record) {\n            if (record[2] === source && record[1] !== value[1]) {\n                found = true\n            }\n        })\n\n        if (!found) {\n            delete scuttle.sources[source]\n        }\n    }\n\n    function set(key, value) {\n        scuttle.localUpdate([key, value])\n    }\n\n    function get(key) {\n        var record = store.get(key)\n\n        return record ? record[0][1] : null\n    }\n\n    function getMergedRecord(update) {\n        var transaction = update[0]\n        var key = transaction[0]\n        var current = store.get(key)\n\n        if (!current) {\n            return update.slice()\n        }\n\n        var currentValue = current[0][1]\n        var currentTs = current[1]\n        var value = transaction[1]\n        var ts = update[1]\n\n        if (typeof currentValue === \"object\" &&\n            typeof value === \"object\" && value !== null\n        ) {\n            if (currentTs > ts) {\n                value = extend({}, value, currentValue)\n            } else {\n                value = extend({}, currentValue, value)\n            }\n        } else if (currentTs > ts) {\n            return false\n        }\n\n        return [[key, value], ts, update[2]]\n    }\n\n    function applyUpdate(update) {\n        var ts = update[1]\n        var key = update[0][0]\n\n        if (ts <= Date.now() - maxAge) {\n            return false\n        }\n\n        var record = getMergedRecord(update)\n\n        if (record === false) {\n            return false\n        } else if (record[0][1] === null) {\n            store.del(key)\n        } else {\n            store.set(key, record)\n        }\n\n        scuttle.emit(\"update\", record[0][0], record[0][1]\n            , record[1], record[2])\n\n        return true\n    }\n\n    function toJSON() {\n        var hash = {}\n\n        store.forEach(function (record, key) {\n            hash[key] = record[0][1]\n        })\n\n        return hash\n    }\n\n    function history(sources) {\n        sources = sources || {}\n        var list = []\n        var now = Date.now()\n\n        store.forEach(function (record, key) {\n            var ts = record[1]\n\n            if (ts > now - maxAge) {\n                if (filter(record, sources)) {\n                    list.push(record)\n                }\n            } else {\n                store.del(key)\n            }\n        })\n\n        return list.sort(function (a, b) {\n            if (a[2] !== b[2]) {\n                return 0\n            }\n\n            return a[1] < b[1] ? -1 : 1\n        })\n    }\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/lru-cache.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/lib/lru-cache.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () { // closure for web browsers\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  var max\n  if (typeof options === 'number') {\n    max = options\n    options = { max: max }\n  }\n\n  if (!options) options = {}\n\n  max = options.max\n\n  var lengthCalculator = options.length || naiveLength\n\n  if (typeof lengthCalculator !== \"function\") {\n    lengthCalculator = naiveLength\n  }\n\n  if (!max || !(typeof max === \"number\") || max <= 0 ) {\n    // a little bit silly.  maybe this should throw?\n    max = Infinity\n  }\n\n  var allowStale = options.stale || false\n\n  var maxAge = options.maxAge || null\n\n  var dispose = options.dispose\n\n  var cache = Object.create(null) // hash of items by key\n    , lruList = Object.create(null) // list of items in order of use recency\n    , mru = 0 // most recently used\n    , length = 0 // number of items in the list\n    , itemCount = 0\n\n\n  // resize the cache when the max changes.\n  Object.defineProperty(this, \"max\",\n    { set : function (mL) {\n        if (!mL || !(typeof mL === \"number\") || mL <= 0 ) mL = Infinity\n        max = mL\n        // if it gets above double max, trim right away.\n        // otherwise, do it whenever it's convenient.\n        if (length > max) trim()\n      }\n    , get : function () { return max }\n    , enumerable : true\n    })\n\n  // resize the cache when the lengthCalculator changes.\n  Object.defineProperty(this, \"lengthCalculator\",\n    { set : function (lC) {\n        if (typeof lC !== \"function\") {\n          lengthCalculator = naiveLength\n          length = itemCount\n          for (var key in cache) {\n            cache[key].length = 1\n          }\n        } else {\n          lengthCalculator = lC\n          length = 0\n          for (var key in cache) {\n            cache[key].length = lengthCalculator(cache[key].value)\n            length += cache[key].length\n          }\n        }\n\n        if (length > max) trim()\n      }\n    , get : function () { return lengthCalculator }\n    , enumerable : true\n    })\n\n  Object.defineProperty(this, \"length\",\n    { get : function () { return length }\n    , enumerable : true\n    })\n\n\n  Object.defineProperty(this, \"itemCount\",\n    { get : function () { return itemCount }\n    , enumerable : true\n    })\n\n  this.forEach = function (fn, thisp) {\n    thisp = thisp || this\n    var i = 0;\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      i++\n      var hit = lruList[k]\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n\n  this.keys = function () {\n    var keys = new Array(itemCount)\n    var i = 0\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      var hit = lruList[k]\n      keys[i++] = hit.key\n    }\n    return keys\n  }\n\n  this.values = function () {\n    var values = new Array(itemCount)\n    var i = 0\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      var hit = lruList[k]\n      values[i++] = hit.value\n    }\n    return values\n  }\n\n  this.reset = function () {\n    if (dispose) {\n      for (var k in cache) {\n        dispose(k, cache[k].value)\n      }\n    }\n    cache = {}\n    lruList = {}\n    mru = 0\n    length = 0\n    itemCount = 0\n  }\n\n  // Provided for debugging/dev purposes only. No promises whatsoever that\n  // this API stays stable.\n  this.dump = function () {\n    return cache\n  }\n\n  this.dumpLru = function () {\n    return lruList\n  }\n\n  this.set = function (key, value) {\n    if (hOP(cache, key)) {\n      // dispose of the old one before overwriting\n      if (dispose) dispose(key, cache[key].value)\n      if (maxAge) cache[key].now = Date.now()\n      cache[key].value = value\n      this.get(key)\n      return true\n    }\n\n    var len = lengthCalculator(value)\n    var age = maxAge ? Date.now() : 0\n    var hit = new Entry(key, value, mru++, len, age)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > max) {\n      if (dispose) dispose(key, value)\n      return false\n    }\n\n    length += hit.length\n    lruList[hit.lu] = cache[key] = hit\n    itemCount ++\n\n    if (length > max) trim()\n    return true\n  }\n\n  this.has = function (key) {\n    if (!hOP(cache, key)) return false\n    var hit = cache[key]\n    if (maxAge && (Date.now() - hit.now > maxAge)) {\n      return false\n    }\n    return true\n  }\n\n  this.get = function (key) {\n    if (!hOP(cache, key)) return\n    var hit = cache[key]\n    if (maxAge && (Date.now() - hit.now > maxAge)) {\n      this.del(key)\n      return allowStale ? hit.value : undefined\n    }\n    delete lruList[hit.lu]\n    hit.lu = mru ++\n    lruList[hit.lu] = hit\n    return hit.value\n  }\n\n  this.del = function (key) {\n    if (!hOP(cache, key)) return\n    var hit = cache[key]\n    if (dispose) dispose(key, hit.value)\n    delete cache[key]\n    delete lruList[hit.lu]\n    length -= hit.length\n    itemCount --\n  }\n\n  function trim () {\n    if (length <= max) return\n    for (var k in lruList) {\n      if (length <= max) break;\n      var hit = lruList[k]\n      if (dispose) dispose(hit.key, hit.value)\n      length -= hit.length\n      itemCount --\n      delete cache[ hit.key ]\n      delete lruList[k]\n    }\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, mru, len, age) {\n  this.key = key\n  this.value = value\n  this.lu = mru\n  this.length = len\n  this.now = age\n}\n\n})()\n\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/lib/lru-cache.js"
));

require.define("/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var widget = require('./widget')\n\nvar hashChange = require('hash-change').on('change', open)\n\nvar rumours = require('rumours')({\n  host: 'http://rumoursdb.com:4567',\n  db: 'r-edit-demo'\n})\n\nvar doc\n\nfunction open(hash) {\n  if(doc) doc.dispose()\n\n  rumours.open('r-edit_' + (hash || 'demo'), function (err, rEdit) {\n    doc = rEdit\n    if(err) throw err\n    document.body.innerHTML = ''\n    document.body.appendChild(rEdit.widget())\n    document.body.appendChild(widget(rEdit))\n  })\n}\n\nopen(hashChange.hash())\n\n\n//@ sourceURL=/client.js"
));
require("/client.js");
})();

